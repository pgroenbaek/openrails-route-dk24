//////////////////////////////////////////////////////////////////////////
//	Danish Signal configuration file 				//
//	This file may be redistributed 					//
//									//
//	Rel. 4.0   							//
//	Copyright:							//
//	Team RouteBuilders DK						//
//	Stig Christensen  27-06-2003					//
//////////////////////////////////////////////////////////////////////////



SCRIPT KBSemRoute
// dk TU armsignal

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!enabled || block_state() ==# BLOCK_JN_OBSTRUCTED )
	
	{
		state = SIGASP_STOP;
	}
	else if ( next_state ==# SIGASP_CLEAR_1 || next_state==# SIGASP_CLEAR_2 )							 
	{
		state = SIGASP_CLEAR_2;
	}
	else if (next_state ==# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	else 
	{
		state = SIGASP_STOP;
	}	

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT KBSemDist
//nyt Script som tager hoejde for foer / efter 1961

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	float		next_state;
	float		Efter_61;

	Efter_61 = sig_feature (SIGFEAT_USER1);
	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( Efter_61 )
	{
//  Efter 1961
		if ( next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			state = SIGASP_APPROACH_2;
		}

	}
	else
	{
//  foer 1961
		if ( next_state ==# SIGASP_STOP ) 
		{
			state = SIGASP_APPROACH_2;
		}
		else
		{
			state = SIGASP_CLEAR_2;
		}
	}
// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT KBSemMain

// Kystbanen Semaphore Signal Main, main arm
	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}


// Get draw state
	draw_state = def_draw_state (state);
//////////////////////////////////////////////////////////////////////////////////////

SCRIPT KBSemEntryHead1

// Kystbanen Semaphore Signal Entry, main arm

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				state = SIGASP_CLEAR_1;
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);


//////////////////////////////////////////////////////////////////////////////////////
SCRIPT KBSemEntryHead2

// Kystbanen Semaphore Signal Entry, entry arm
// When down/yellow: slow speed
// When up/green:    go through

	extern float	this_sig_lr ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);
	state = SIGASP_STOP;
	if (this_state ==# SIGASP_CLEAR_2)

	{
	state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);
//////////////////////////////////////////////////////////////////////////////////////

SCRIPT dkam
// dkam signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		VD;


	VD = sig_feature (SIGFEAT_USER1);
	next_state = next_sig_lr (SIGFN_NORMAL);

	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( enabled ) 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 || next_state ==# SIGASP_APPROACH_3)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			state = SIGASP_CLEAR_1;
		}
	}
	else
	{
		if ( VD )	
		{
			state = SIGASP_STOP;
		}
		else 
		{
			state = SIGASP_RESTRICTING;
		}

	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dkamsbane
// dk am signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;



	next_state = next_sig_lr (SIGFN_NORMAL);

	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( !enabled ) 
	{
		state = SIGASP_RESTRICTING;
	}
	else 
	{
	if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 || next_state ==# SIGASP_APPROACH_3)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			state = SIGASP_CLEAR_1;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk2udsbane
// dk  ud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SU;


	SU = sig_feature (SIGFEAT_USER1);


// If required, show the 'stop' indication.
	if ( !route_set ()|| !enabled || block_state() !=# BLOCK_CLEAR )
	// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 ||
			next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			if ( SU )
			{
				state = SIGASP_APPROACH_3;
			}
			else
			{
				state = SIGASP_CLEAR_1;
			}
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dk2ud
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk3ud
// dk ud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SU;


	SU = sig_feature (SIGFEAT_USER1);



	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else 
	{
	if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			if ( SU )
			{
				state = SIGASP_APPROACH_3;
			}
			else
			{
				state = SIGASP_CLEAR_1;
			}
		}
	}

// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4ind

// dkind signal head 4 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4ind_old

// dkind signal head 4 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT dk1distant

// Dk distant signal

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	state = SIGASP_APPROACH_2;

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dk2distant

// Dk distant signal

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);

	state = SIGASP_APPROACH_2;
	if (next_state ==# SIGASP_CLEAR_1 ||
		next_state ==# SIGASP_CLEAR_2) 
	{
		state = SIGASP_CLEAR_1;
	}
// Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////////
SCRIPT dk3distant

// Dk distant signal

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	next_state = next_sig_lr (SIGFN_INFO);

	state = SIGASP_APPROACH_2;
	if (next_state ==# SIGASP_CLEAR_1) 
	{
		state = SIGASP_CLEAR_1;
	}

	else if (next_state ==# SIGASP_CLEAR_2) 

	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dktusig
// dk TU signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!enabled || block_state() ==# BLOCK_JN_OBSTRUCTED )
	
	{
		state = SIGASP_STOP;
	}
	else if ( next_state ==# SIGASP_CLEAR_1 || next_state==# SIGASP_CLEAR_2 )							 
	{
		state = SIGASP_CLEAR_2;
	}
	else if (next_state ==# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	else 
	{
		state = SIGASP_STOP;
	}	

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkunsecskilt
// dk unsecure area follows

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

		state = SIGASP_APPROACH_1;


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkstopskilt
// dk STOP SIGN

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

		state = SIGASP_STOP;


// Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////////




SCRIPT dk-dvsig

// dk Dvaerg signal head

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		rangerspor;


	rangerspor = sig_feature (SIGFEAT_USER1);

// If required, show the 'stop' indication.

	if (!enabled ) 
	{
		if ( rangerspor ) 
		{		
			state = SIGASP_STOP_AND_PROCEED;
		}
		else	
		{
			state = SIGASP_STOP;
		}
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED ) 
	// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else 
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);
		state = SIGASP_RESTRICTING;

		if (next_state ==# SIGASP_APPROACH_1 || next_state ==# SIGASP_RESTRICTING ) 
		{
			state = SIGASP_APPROACH_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_2; 
		}
		else if(next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_APPROACH_3;
		}
		else if(next_state ==# SIGASP_CLEAR_1)
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk5indv

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT left_arm

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 
			state = SIGASP_APPROACH_3;
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT dk6indv

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Left_arm_g

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);



// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);




///////////////////////////////////////////////////////////////////////////////

SCRIPT dk5indh

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 

			state = SIGASP_APPROACH_3;

		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk6indh

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm_g

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);


// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);




///////////////////////////////////////////////////////////////////////////////

SCRIPT dkhviser

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		wait;
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		Diverte_route_40;
	float		SI_ahead;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);
	Diverte_route_40 = sig_feature (SIGFEAT_USER4);
	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);

	this_state = this_sig_lr(SIGFN_INFO);
	next_state = next_sig_lr(SIGFN_NORMAL);


if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1 )
		{	
			if ( Diverte_route_40 )
			{
				state = SIGASP_APPROACH_1;
			}
			else
			{
				state = SIGASP_APPROACH_2;
			}
		}

	else if (this_state ==# SIGASP_CLEAR_1 || this_state ==# SIGASP_CLEAR_2)
		{
			if (Main_track_40)
			{
				state = SIGASP_APPROACH_1;
			}
			else if (Main_track_60)
			{
				state = SIGASP_APPROACH_2;
			}
			else
			{
				state = SIGASP_CLEAR_1;
				if (SI_ahead &&
 (next_state !=# SIGASP_CLEAR_1 && next_state !=# SIGASP_CLEAR_2 && next_state !=# SIGASP_APPROACH_3))
				{
					state = SIGASP_APPROACH_3;
				}

			}
		}
		else if (this_state ==# SIGASP_APPROACH_3 )
		{	
			if ( Side_track_40 || !route_set() )
			{
				state = SIGASP_APPROACH_1;
			}
			else
			{
				state = SIGASP_APPROACH_2;
			}
		}
		else if (this_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_1;
		}
		else
		{
			state = SIGASP_STOP;
		}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dk3ind_old

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		if (route_set() )
			{
				state = SIGASP_CLEAR_1;
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		else
		{
			state = SIGASP_APPROACH_3;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dk3ind

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		if (route_set() )
			{
				state = SIGASP_CLEAR_1;
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		else
		{
			state = SIGASP_APPROACH_3;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dkvisig

// dk platform signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if ( !enabled )
	{
		state = SIGASP_RESTRICTING;
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_APPROACH_1;
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dkvusig

// dk platform signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if ( !enabled )
	{
		state = SIGASP_RESTRICTING;
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_APPROACH_3;
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dkpusig

// dk platform signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
if (block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	else if (!enabled || block_state() ==# BLOCK_OCCUPIED ) 		// Block ahead not clear?
									
	{
		state = SIGASP_RESTRICTING;
	}
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP )
		{
			state = SIGASP_RESTRICTING;
		}
		else if (next_state ==# SIGASP_APPROACH_1 || next_state ==# SIGASP_RESTRICTING) 
		{
			state = SIGASP_APPROACH_2;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_2; 
		}
		else if(next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_APPROACH_3;
		}
		else
		{
			state = SIGASP_CLEAR_2;
		}

	}


// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_2udsighkt

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	extern float	route_set ();
	float		next_state;

// If required, show the 'stop' indication.
	 if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED)
 	// Block ahead not clear?
									
	{
		state = SIGASP_STOP;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dkhktblok

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication.
	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( !enabled ) 
	{
		state = SIGASP_RESTRICTING;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_amsighkt

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication.
	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( !enabled ) 
	{
		state = SIGASP_RESTRICTING;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dkindhkt

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;
	float		Main_track_70;
	float		Main_track_50;
	float		Side_track_70;
	float		Side_track_50;

	Main_track_70 = sig_feature (SIGFEAT_USER1);
	Main_track_50 = sig_feature (SIGFEAT_USER2);
	Side_track_70 = sig_feature (SIGFEAT_USER3);
	Side_track_50 = sig_feature (SIGFEAT_USER4);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		state = SIGASP_APPROACH_1;

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if (next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if (next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
	}
	if (route_set() && Main_track_70 && state >=# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	if (route_set() && Main_track_50 && state >=# SIGASP_APPROACH_2 )
	{
		state = SIGASP_APPROACH_2;
	}
	if (!route_set() && Side_track_70 && state >=# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	if (!route_set() && Side_track_50 && state >=# SIGASP_APPROACH_2 )
	{
		state = SIGASP_APPROACH_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkpusighkt

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication.
	 if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED)
 	// Block ahead not clear?
									
	{
		state = SIGASP_STOP;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dk-dvsighkt

// dk Dvaerg signal head

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		rangerspor;


	rangerspor = sig_feature (SIGFEAT_USER1);

// If required, show the 'stop' indication.

	if (!enabled ) 
	{
		if ( rangerspor ) 
		{		
			state = SIGASP_STOP_AND_PROCEED;
		}
		else	
		{
			state = SIGASP_STOP;
		}
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED ) 
	// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else 
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);
		state = SIGASP_RESTRICTING;

		if ( next_state ==# SIGASP_RESTRICTING ) 
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1  ) 
		{
			state = SIGASP_APPROACH_2;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_bogvis_A
// dk bogstavsviser A

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show A
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_B
// dk bogstavsviser B

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show B
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_C
// dk bogstavsviser C

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show C
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_D
// dk bogstavsviser D

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show D
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_E
// dk bogstavsviser E

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show E
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_F
// dk bogstavsviser F

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show F
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);
//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_G
// dk bogstavsviser G

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show G
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////

SCRIPT dk_bogvis_H
// dk bogstavsviser H

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show H
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_K
// dk bogstavsviser K

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show K
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_L
// dk bogstavsviser L

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show L
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_M
// dk bogstavsviser M

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show M
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_N
// dk bogstavsviser N

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show N
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_O
// dk bogstavsviser O

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show O
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_P
// dk bogstavsviser P

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show P
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_R
// dk bogstavsviser R

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show R
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_S
// dk bogstavsviser S

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show S
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_T
// dk bogstavsviser T

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal = sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show G
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_U
// dk bogstavsviser U

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal = sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show U
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_V
// dk bogstavsviser V

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal = sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 || (this_state !=# SIGASP_STOP && is_HKT_signal) )
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show V
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_OE
// dk bogstavsviser OE

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show OE
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////

SCRIPT dk_retviser_L
// dk Retningsviser Left

	extern float	route_set ();
	extern float	this_sig_mr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state = this_sig_mr (SIGFN_NORMAL);
	state = SIGASP_STOP;

	if (this_state !=# SIGASP_STOP)
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show Left
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);
	

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_retviser_R
// dk Retningsviser Right

	extern float	route_set ();
	extern float	this_sig_mr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state = this_sig_mr (SIGFN_NORMAL);
	state = SIGASP_STOP;

	if (this_state !=# SIGASP_STOP)
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show Right
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver7sig
// dk Aktiver 7 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver9sig
// dk Aktiver 9 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver11sig
// dk Aktiver 11 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver13sig
// dk Aktiver 13 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver15sig
// dk Aktiver 15 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver17sig
// dk Aktiver 17 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver19sig
// dk Aktiver 19 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT KBsig_Point

// Sporskiftesignal

	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	if ( route_set() )		// Switch set as per link (straight branch)?
	{
		state = SIGASP_CLEAR_2;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed30

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		wait;
	float		next_state;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);
	next_state = next_sig_lr(SIGFN_NORMAL);


if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}




// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed40

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed50

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed60

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed80

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_2;	
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed100

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_2;	
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed120

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_2;	
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed130

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_2;	
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed140

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_2;	
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4indv_old

// dkind signal head 4 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
//		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			SI_state = next_sig_lr (SIGFN_INFO);
			state = SIGASP_CLEAR_1;
			if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
			{
				state = SIGASP_CLEAR_2;
			} 
			else
			{
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT dk5indv_old

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT left_arm_old

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 
			state = SIGASP_APPROACH_3;
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT dk6indv_old

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Left_arm_g_old

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);



// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4indh_old

// dkind signal head 4 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
//		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
		
			SI_state = next_sig_lr (SIGFN_INFO);
			state = SIGASP_CLEAR_1;
			if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
			{
				state = SIGASP_CLEAR_2;
			} 
			else
			{
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);



///////////////////////////////////////////////////////////////////////////////

SCRIPT dk5indh_old

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm_old

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 

			state = SIGASP_APPROACH_3;

		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk6indh_old

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm_g_old

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);


// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT dktusig_bag
// dk TU signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

	state = this_sig_lr (SIGFN_NORMAL);

//	if (!enabled || block_state() ==# BLOCK_JN_OBSTRUCTED )
//	
//	{
//		state = SIGASP_STOP;
//	}
//	else if ( next_state ==# SIGASP_CLEAR_1 || next_state==# SIGASP_CLEAR_2 )							 
//	{
//		state = SIGASP_CLEAR_2;
//	}
//	else if (next_state ==# SIGASP_APPROACH_3 )
//	{
//		state = SIGASP_APPROACH_3;
//	}
//	else 
//	{
//		state = SIGASP_STOP;
//	}	

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivind

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		if ( route_set() )
			{
				state = SIGASP_CLEAR_1;
			}
		else
		{
			state = SIGASP_APPROACH_3;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dkprivud
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// If required, show the 'stop' indication.
	if ( route_set () && enabled && block_state() ==# BLOCK_CLEAR )	// Block ahead not clear?
							 
	{
		state = SIGASP_CLEAR_2;
	}
	else
	{
		state = SIGASP_STOP;	
	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivud2
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	opp_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication

		state = next_sig_lr ( SIGFN_INFO );


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivper
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;
	float		sidespor;


	sidespor = sig_feature ( SIGFEAT_USER1 );

	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( route_set () && enabled && block_state() !=# BLOCK_JN_OBSTRUCTED && next_state ==# SIGASP_CLEAR_2 )
	// Block ahead not clear?
	{
		if ( sidespor )
			{
				state = SIGASP_APPROACH_3;
			}
		else
			{
				state = SIGASP_CLEAR_2;
			}
	}
	else
	{
			state = SIGASP_STOP;
	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivper2
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		sidespor;

	sidespor = sig_feature ( SIGFEAT_USER1 );

// If required, show the 'stop' indication.
	if ( sidespor )	// Block ahead not clear?
							 
	{
		state = SIGASP_APPROACH_3;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}


// Get draw state
	draw_state = def_draw_state (state);







////////////////////////////////////////    SWEDISH SIGNALS //////////////////////////////////////////



// ****************************************************************************
SCRIPT PriWarn5Light
// Infart / Forsignal, 5 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; // Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; // Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; // Show Clear next clear40
			}
			else 
			{
				state = SIGASP_APPROACH_2; // Show Clear next stop
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);


// ****************************************************************************
SCRIPT PriWarn5LightS
// Infart / Forsignal, 5 lampor, stolpe
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; // Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; // Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; // Show Clear next clear40
			}
			else 
			{
				state = SIGASP_APPROACH_2; // Show Clear next stop
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT PriWarn5LightK70
// Infart / Forsignal, 5 lampor, K70
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; // Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; // Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; // Show Clear next clear40
			}
			else 
			{
				state = SIGASP_APPROACH_2; // Show Clear next stop
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);



// ****************************************************************************
SCRIPT PriWarn5LightK40kf
// Infart / Forsignal, 5 lampor, K40 istllet fr Kr-nsta stopp
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; 									// Show Stop, block occupied
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; 							// Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; 						// Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; 						// Show Clear next clear40
			}
			else 
			{
				state = SIGASP_APPROACH_1; 						// Show Clear40 (normally S C N stop)
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT PriWarn5LightK40ks
// Infart / Forsignal, 5 lampor, K40 istllet fr Kr-nsta stopp, stolpe
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; 									// Show Stop, block occupied
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; 							// Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; 						// Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; 						// Show Clear next clear40
			}
			else 
			{
				state = SIGASP_APPROACH_1; 						// Show Clear40 (normally S C N stop)
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);


// ****************************************************************************
SCRIPT PriWarn5LightK70kf
// Infart / Forsignal, 5 lampor, K70 istllet fr Kr-nsta stopp
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; 									// Show Stop, block occupied
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; 							// Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; 						// Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; 						// Show Clear next clear40
			}
			else 
			{
				state = SIGASP_APPROACH_1; 						// Show Clear40 (normally S C N stop)
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT PriWarn5LightK70ks
// Infart / Forsignal, 5 lampor, K70 istllet fr Kr-nsta stopp, stolpe
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; 									// Show Stop, block occupied
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; 							// Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; 						// Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; 						// Show Clear next clear40
			}
			else 
			{
				state = SIGASP_APPROACH_1; 						// Show Clear40 (normally S C N stop)
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);




// ****************************************************************************
SCRIPT PriMiddleWarn5Light
// Infart-Mellan / Forsignal, 5 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP)
		{
			state = SIGASP_STOP; // Show Stop
		}
		else
		{
			if (!route_set())
			{
				state = SIGASP_APPROACH_1; // Show Clear40
			}
			else
			{
				if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
				{
					state = SIGASP_CLEAR_1; // Show Clear next clear
				}
				else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
				{
					state = SIGASP_APPROACH_3; // Show Clear next clear40
				}
				else 
				{
					state = SIGASP_APPROACH_2; // Show Clear next stop
				}
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT PriWarn5SLight
// Infart / Forsignal, kort vag, 5 lampor
// ****************************************************************************


	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; // Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; // Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; // Show Clear next clear40
			}
			else 
			{
				state = SIGASP_RESTRICTING; // Show Clear40 short
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT PriWarn5ScLight
// Infart / Forsignal, kort vag, 5 lampor, Kor
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		if (route_set())
		{
			state = SIGASP_RESTRICTING; // Show Clear40 Short
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; // Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; // Show Clear next clear40
			}
			else 
			{
				state = SIGASP_APPROACH_2; // Show Clear next stop
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);
// ****************************************************************************
SCRIPT PriWarn5ScLightS
// Infart / Forsignal, kort vag, 5 lampor, Kor
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_RESTRICTING; // Show Clear40 Short
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; // Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; // Show Clear next clear40
			}
			else 
			{
				state = SIGASP_APPROACH_2; // Show Clear next stop
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);


// ****************************************************************************
SCRIPT PriWarn4Light
// Infart / Forsignal, 4 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; // Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; // Show Clear next clear
			}
			else 
			{
				state = SIGASP_APPROACH_2; // Show Clear next stop
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT PriWarn4LightK40Kf
// Infart / Forsignal, 4 lampor, visa K40 vid Clear_Next_Stop
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; 						// Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; 				// Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; 			// Show Clear next clear
			}
			else 
			{
				state = SIGASP_APPROACH_1; 			// Show Clear 40 (clear next stop normally)
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT PriWarn4LightK70Kf
// Infart / Forsignal, 4 lampor, visa K70 vid Clear_Next_Stop
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; 						// Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; 				// Show Clear70
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; 			// Show Clear next clear
			}
			else 
			{
				state = SIGASP_APPROACH_1; 			// Show Clear70 (clear next stop normally)
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);



// ****************************************************************************
SCRIPT Pri3Light
// Infartssignal, 3 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; 				// Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; 		// Show Clear40
		}
		else
		{
			state = SIGASP_CLEAR_2; 		// Show Clear
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Pri3LightK70
// Infartssignal, 3 lampor, kr70
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; // Show Clear40
		}
		else
		{
			state = SIGASP_CLEAR_2; // Show Clear
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);


// ****************************************************************************
SCRIPT InfDwarf7Light
// Infartssignal, Dvarg, 7 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_1; // Show Clear40
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);
			
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; // Show Clear
			}
			else 
			{
				state = SIGASP_APPROACH_2; // Show Clear careful
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT InfDwarf4Loc
// Infartssignal, Dvarg, 7 lampor, Kor40 eller Lokal, for utfarter fran bang.
// ****************************************************************************

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled)
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		if (!route_set())
		{
			state = SIGASP_APPROACH_2; // Show Local
		}
		else
		{
			next_state = next_sig_lr (SIGFN_NORMAL);

			if (block_state() !=# BLOCK_CLEAR || next_state ==# SIGASP_STOP) {
				state = SIGASP_STOP; // Show Stop
			}
			else	
			{
				state = SIGASP_APPROACH_1; // Show Clear 40
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);


// ****************************************************************************
SCRIPT Block5Light
// Block / Forsignal, 5 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
			
		if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_1; // Show Clear next clear
		}
		else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_3; // Show Clear next clear40
		}
		else 
		{
			state = SIGASP_APPROACH_2; // Show Clear next stop
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Block5SLight
// Block / Forsignal, 5 lampor, kort vag
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
			
		if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_1; // Show Clear next clear
		}
		else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_3; // Show Clear next clear40
		}
		else 
		{
			state = SIGASP_RESTRICTING; // Show Clear40 Short
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Block4Light
// Block / Forsignal, 4 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
			
		if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_1; // Show Clear next clear
		}
		else 
		{
			state = SIGASP_APPROACH_2; // Show Clear next stop
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Block2Light
// Blocksignal, 2 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		state = SIGASP_CLEAR_2; // Show Clear
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Block3LightK40
// Blocksignal, 3 lampor. kr 40
// ****************************************************************************

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; 				// Show Stop
	}
	else 
	{
		state = SIGASP_APPROACH_1; 			// Show Clear 40
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Block3LightK70
// Blocksignal, 3 lampor. kr 70
// ****************************************************************************

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		state = SIGASP_APPROACH_1; // Show Clear 40/70
	}

	// Get draw state
	draw_state = def_draw_state (state);




// ****************************************************************************
SCRIPT PriDwarf7Light
// Huvuddvargsignal, 7 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
			
		if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1; 								// Show Clear40 careful
		}
		else if (next_state ==# SIGASP_APPROACH_3)
		{
			state = SIGASP_APPROACH_3; 								// Show Clear next clear40
		}
		else if (next_state ==# SIGASP_CLEAR_2 || next_state ==# SIGASP_CLEAR_1 )
		{
			state = SIGASP_CLEAR_2; 								// Show Clear
		}
		else if (next_state ==# SIGASP_STOP )
		{
			state = SIGASP_STOP;	 								// Show Clear
		}
		else 
		{
			state = SIGASP_APPROACH_2; 								// Show Clear careful
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Block40_5Light
// Blocksignal, 5 lampor, Kor 40
// ****************************************************************************

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		state = SIGASP_APPROACH_1; // Show Clear40
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Block40_Dwarf7Light
// Blocksignal, 7 lampor, Dwarf, Kor 40
// ****************************************************************************

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		state = SIGASP_APPROACH_1; // Show Clear40
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Middle5Light
// Mellansignal, 5 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP)
		{
			state = SIGASP_STOP; // Show Stop
		}
		else
		{
			if (next_state ==# SIGASP_APPROACH_2 || next_state ==# SIGASP_APPROACH_3 || next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
			{
				state = SIGASP_CLEAR_1; // Show Clear next clear
			}
			else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
			{
				state = SIGASP_APPROACH_3; // Show Clear next clear40
			}
			else 
			{
				state = SIGASP_APPROACH_2; // Show Clear next stop
			}
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Middle40_5Light
// Mellansignal, 5 lampor, Kor 40
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP)
		{
			state = SIGASP_STOP; // Show Stop
		}
		else
		{
			state = SIGASP_APPROACH_1; // Show Clear40
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Middle3Light
// Mellansignal, 3 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
			
		if (next_state !=# SIGASP_STOP)
		{
			state = SIGASP_APPROACH_1; // Show Clear40
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Middle3LightLn
// Mellansignal, 3 lampor, K70 linked
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; 				// Show Stop, block occupied
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
			
		if (next_state ==# SIGASP_STOP)
		{
			state = SIGASP_STOP; 			// Show Stop, next in stop
		}
		else if (!route_set())
		{
			state = SIGASP_APPROACH_1; 		// Show Clear40
		}
		else
		{
			state = SIGASP_CLEAR_1; 		// Show Clear
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);
// ****************************************************************************
SCRIPT Middle3LightLnK70
// Mellansignal, 3 lampor, K70 linked
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; 				// Show Stop, block occupied
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
			
		if (next_state ==# SIGASP_STOP)
		{
			state = SIGASP_STOP; 			// Show Stop, next in stop
		}
		else if (!route_set())
		{
			state = SIGASP_APPROACH_1; 		// Show Clear40
		}
		else
		{
			state = SIGASP_CLEAR_1; 		// Show Clear
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);



// ****************************************************************************
SCRIPT Middle3LightK70
// Mellansignal, 3 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
			
		if (next_state !=# SIGASP_STOP)
		{
			state = SIGASP_APPROACH_1; // Show Clear40
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Middle3LightDv4
// Mellansignal med 3 lampor, dvrgsignal, K40 i huvudspr
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!route_set())
	{
		if (!enabled || block_state() !=# BLOCK_CLEAR )
		{
			state = SIGASP_RESTRICTING; 			// Show Move carefully
		}
		else
		{
			state = SIGASP_APPROACH_1; 			// Show Move
		}
	}
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (!enabled || block_state() !=# BLOCK_CLEAR )
		{
			state = SIGASP_STOP; 				// Show Stop
		}
		else if (next_state ==# SIGASP_STOP)
		{
			state = SIGASP_STOP; 				// Show Stop
		}
		else 
		{
			state = SIGASP_APPROACH_2; 			// Show Clear K40
		}
	}
	

	// Get draw state
	draw_state = def_draw_state (state);


// ****************************************************************************
SCRIPT Middle2Light
// Mellansignal, 2 lampor
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
			
		if (next_state !=# SIGASP_STOP)
		{
			state = SIGASP_CLEAR_2; // Show Clear
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);
// ****************************************************************************
SCRIPT V_Pri_1Light
// V-signal, 1 lampa, frsignalfunktion
// ****************************************************************************

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);
			
	if (next_state ==# SIGASP_STOP)
	{
		state = SIGASP_STOP; // Show stop
	}
	else
	{
		state = SIGASP_CLEAR_2; // Show clear
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT V_Blo_1Light
// V-signal, 1 lampa, blocksignalfunktion
// ****************************************************************************


	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		state = SIGASP_CLEAR_2; // Show Clear
	}

	// Get draw state
	draw_state = def_draw_state (state);



// ****************************************************************************
SCRIPT Warn3Light
// Forsignal, 3 lampor
// ****************************************************************************

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP) 			//Nasta stopp, visa "vanta stopp"
		{
			state = SIGASP_APPROACH_2;
		}
		else if (next_state ==# SIGASP_APPROACH_1 ||
		         next_state ==# SIGASP_RESTRICTING) 	//Nasta K40 (avkortad), visa "vanta K40"
		{
			state = SIGASP_APPROACH_3;
		}
		else if (next_state ==# SIGASP_CLEAR_1) 		//Nasta kor, visa "vanta kor"
		{
			state = SIGASP_CLEAR_1;
		}

		else 								//Nasta kor, visa "vanta kor"
		{
			state = SIGASP_CLEAR_1;
		}
	

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Warn1Light
// Forsignal, 1 lampor
// ****************************************************************************

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);
			
	if (next_state ==# SIGASP_STOP)
	{
		state = SIGASP_APPROACH_2; // Show Next stop
	}
	else
	{
		state = SIGASP_CLEAR_1; // Show Next clear/clear40
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Cross1Light
// V-signal, 1 lampa
// ****************************************************************************

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = SIGASP_CLEAR_2;

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT WarnCross3Light
// V-forsignal, 3 lampor
// ****************************************************************************

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	next_state = next_sig_lr (SIGFN_INFO);
			
	if (next_state ==# SIGASP_STOP)
	{
		state = SIGASP_STOP; // Show Next stop
	}
	else
	{
		state = SIGASP_CLEAR_2; // Show Next clear
	}

	// Get draw state
	draw_state = def_draw_state (state);


// ****************************************************************************
SCRIPT Bridge1Light
// Brosignal, 1 lampa
// ****************************************************************************

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = SIGASP_CLEAR_2;

	// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Dwarf4Light
////////////////////////////////////
// Dvargsignal, 4 lampor
////////////////////////////////////


	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;
	float		next_sh_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		next_sh_state = next_sig_lr (SIGFN_SHUNTING);

		if (next_state !=# SIGASP_STOP || next_sh_state !=# SIGASP_STOP)
		{
			state = SIGASP_CLEAR_2; // Show Move
		}
		else 
		{
			state = SIGASP_APPROACH_2; // Show Move Obstruction
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Dwarf4Light_Local
////////////////////////////////////
// Dvargsignal, 4 lampor, Lokal
////////////////////////////////////

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = SIGASP_APPROACH_1;

	// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Dwarf4Light_Shunt
////////////////////////////////////
// Dvargsignal, 4 lampor, Ej Forsignalering
////////////////////////////////////

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;
	float		next_sh_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		next_sh_state = next_sig_lr (SIGFN_SHUNTING);

		if (next_state !=# SIGASP_STOP || next_sh_state !=# SIGASP_STOP)
		{
			state = SIGASP_CLEAR_2; // Show Move
		}
		else 
		{
			state = SIGASP_APPROACH_2; // Show Move Obstruction
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Dwarf4Light_Under
////////////////////////////////////
// Dvargsignal, 4 lampor, Undersignal
////////////////////////////////////

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		state = SIGASP_CLEAR_2; // Show Move
	}

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT Dwarf4Light_Middle_INF
// Dvargsignal, 4 lampor, INFO-signal i kombination med huvudsignal
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	if (!enabled || block_state() !=# BLOCK_CLEAR )
	{
		state = SIGASP_STOP; // Show Stop
	}
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
			
		if (next_state !=# SIGASP_STOP)
		{
			state = SIGASP_CLEAR_2; // Show Clear
		}
	}

	// Get draw state
	draw_state = def_draw_state (state);


// ****************************************************************************
SCRIPT Middle_Dwarf7Light
// Mellandvrgsignal, 7 lampor, INFO
// ****************************************************************************

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	
	next_state = next_sig_lr (SIGFN_NORMAL);

	if (next_state ==# SIGASP_STOP)
	{
		state = SIGASP_STOP; 				// Show Stop
	}
	else if (next_state ==# SIGASP_RESTRICTING || next_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_1; 			// Show Clear40
	}
	else if (next_state ==# SIGASP_APPROACH_2)
	{
		state = SIGASP_APPROACH_2; 			// Show Clear40 careful
	}
	else if (next_state ==# SIGASP_APPROACH_3)
	{
		state = SIGASP_APPROACH_3; 			// Show Clear careful
	}
	else if (next_state ==# SIGASP_CLEAR_2 || next_state ==# SIGASP_CLEAR_1 )
	{
		state = SIGASP_CLEAR_2; 			// Show Clear
	}
	

	// Get draw state
	draw_state = def_draw_state (state);


// ****************************************************************************
SCRIPT Stop1Light
// Stoppsignal, 1 lampa
// ****************************************************************************

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = SIGASP_STOP;

	// Get draw state
	draw_state = def_draw_state (state);

// ****************************************************************************
SCRIPT SSign
// S-Skylt
// ****************************************************************************

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = SIGASP_APPROACH_1; // Show "local"

	// Get draw state
	draw_state = def_draw_state (state);

// Deutsches Eisenbahnsignalpaket
// Erstellt und getestet von Dennis Kunz, 2012
// Version 1.1b - 07.04.12

SCRIPT KS_MAIN

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		next_state;
	float		h_n_p;
	float		next_state_rptr;
	float		cfgsig_mr;
	float		cfgsig_lr;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );

	state = 7;
	draw_state = 0;

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		if ( block_state() !=# BLOCK_CLEAR )
		{
			state = 0;
			return;
		}
	}
	else
	{
		if ( !enabled or block_state() !=# BLOCK_CLEAR )
		{
			state = 0;
			return;
		}
	}

	if ( h_n_p and next_state ==# 0 )
	{
		state = 0;
		return;
	}

	if ( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 and next_state ==# 0 )
	{
		state = 0;
		return;	
	}

	if ( next_state ==# 1 and sig_feature ( SIGFEAT_USER2 ) )
	{
		state = 0;
		return;
	}
	
	if ( speed_reduction ==# 2 )
	{
		state = 2;
		return;	
	}

	if ( speed_reduction < 7 and speed_reduction > 2 )
	{	
		state = speed_reduction;
		return;
	}

	if ( speed_reduction ==# 7 )
	{
		state = 7;
		return;
	}

	if ( speed_reduction <=# 0 )
	{
		state = 0;
		return;
	}

	return;


SCRIPT KS_OPTIK_ROT

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_OPTIK_GELB

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		next_state_rptr;
	float		next_state;
	float		h_n_p;
	float		h_g_p;
	float		this_state;
	float		cfgsig_mr;
	float		cfgsig_lr;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );
	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );

	h_g_p = sig_feature ( SIGFEAT_GRADIENT_PLATE ) or 
			( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 );

	state = 7;
	draw_state = 0;

	if ( this_state ==# -1 )
	{
		if ( ( next_state < 3 and not h_g_p ) or ( ( next_state_rptr ==# 1 ) and h_g_p ) )
		{
			draw_state = 1;
		}
	}
	else
	{	
		if ( this_state < 3 )
		{
			draw_state = 0;
		}
		else
		{
			if ( ( next_state < 3 and not h_g_p ) or ( ( next_state_rptr ==# 1 ) and h_g_p ) )
			{
				draw_state = 1;
			}
			else
			{
				draw_state = 0;
			}
		}
	}

	return;


SCRIPT KS_OPTIK_GRUEN

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		next_state_rptr;
	float		next_state;
	float		h_n_p;
	float		h_g_p;
	float		this_state;
	float		cfgsig_mr;
	float		cfgsig_lr;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );
	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );

	h_g_p = sig_feature ( SIGFEAT_GRADIENT_PLATE ) or 
			( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 );

	state = 7;
	draw_state = 0;

	if ( this_state ==# -1 )
	{
		if ( ( next_state ==# 7 and not h_g_p ) or ( ( next_state_rptr ==# 7 ) and h_g_p ) )
		{
			draw_state = 1;
		}
		else
		{
			draw_state = 0;
		}
	}
	else
	{
		if ( this_state < 3 or next_state < 3 ) // next_state_rptr einfgen !!
		{
			draw_state = 0;
		}
		else
		{
			if ( ( next_state > 6 and not h_g_p ) or ( next_state_rptr > 6 and h_g_p ) or
				( next_state >=# this_state and not h_g_p ) or ( next_state_rptr >=# this_state and h_g_p ) )
			{
				draw_state = 1;
			}
		}
	}

	return;


SCRIPT KS_OPTIK_GRUEN_HS

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state > 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_OPTIK_GRUEN_BL_A

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		next_state_rptr;
	float		h_g_p;
	float		cfgsig_mr;
	float		cfgsig_lr;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state	= next_sig_lr ( SIGFN_NORMAL );
	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );

	h_g_p = sig_feature ( SIGFEAT_GRADIENT_PLATE ) or 
		( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 );

	state = 7;
	draw_state = 0;

	if ( ( ( next_state < this_state ) and next_state > 2 ) and not h_g_p )
	{
		draw_state = 1;
		return;
	}

	if ( ( ( next_state_rptr < this_state ) and next_state_rptr > 2 ) and h_g_p )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_OPTIK_GRUEN_BL_B

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state	= next_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;
	
	if ( next_state < 7 and next_state > 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_OPTIK_GRUEN_BL_C

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state	= next_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( next_state < 7 and next_state > 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_OPTIK_WEISS1

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_OPTIK_WEISS2

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_OPTIK_WEISS3_A

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		next_state_inf;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf	= next_sig_lr ( SIGFN_INFO );

	state = 7;
	draw_state = 0;

	if ( ( next_state < this_state ) and next_state_inf ==# 4 )
 	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_OPTIK_WEISS3_B

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		next_state_inf;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf	= next_sig_lr ( SIGFN_INFO );

	state = 7;
	draw_state = 0;

	if ( this_state < 0 )
	{	
		if ( next_state < 7 and next_state_inf ==# 4 )
		{
			draw_state = 1;
			return;
		}
	
		return;
	}

	return;


SCRIPT KS_OPTIK_WEISS3_C

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		next_state_inf;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf	= next_sig_lr ( SIGFN_INFO );

	state = 7;
	draw_state = 1;

	if ( next_state ==# 7 )
 	{
		draw_state = 0;
		return;
	}

	return;


SCRIPT KS_ZS3_30_A

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	state;
	extern float	draw_state;

	float		cfgsig_mr;
	float		cfgsig_lr;
	float		next_state;
	float		h_n_p;
	float		next_state_rptr;

	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );

	if ( !enabled or block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
		draw_state = 0;
		return;
	}
	else
	{
		if ( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 )
		{
			state = 7;
			draw_state = 1;
			return;	
		}
	}

	return;


SCRIPT KS_ZS3V_30

	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_rptr;
	float		h_g_p;
	float		cfgsig_mr;
	float		cfgsig_lr;

	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 )
	{
		draw_state = 1;
		return;	
	}

	return;


SCRIPT KS_ZS3_40

	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# 3 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_ZS3V_40

	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 0 )
	{
		if ( ( next_state ==# 3 and not h_g_p ) or ( ( next_state_rptr ==# 3 ) and h_g_p ) )
		{
			draw_state = 1;
			return;
		}

		return;
	}

	if ( this_state < 3 or ( ( next_state >=# this_state ) and not h_g_p ) )
	{
		draw_state = 0;
		return;
	}

	if ( ( ( next_state ==# 3 ) and not h_g_p ) or ( ( next_state_rptr ==# 3 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_ZS3_60

	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# 4 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_ZS3V_60

	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 0 )
	{
		if ( next_state ==# 4 or ( ( next_state_rptr ==# 4 ) and h_g_p ) )
		{
			draw_state = 1;
			return;
		}

		return;
	}

	if ( this_state < 3 or ( ( next_state >=# this_state ) and not h_g_p ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state ==# 4 or ( ( next_state_rptr ==# 4 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_ZS3_80

	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# 5 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_ZS3V_80

	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 0 )
	{
		if ( next_state ==# 5 or ( ( next_state_rptr ==# 5 ) and h_g_p ) )
		{
			draw_state = 1;
			return;
		}

		return;
	}

	if ( this_state < 3 or ( ( next_state >=# this_state ) and not h_g_p ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state ==# 5 or ( ( next_state_rptr ==# 5 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_ZS3_100

	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# 6 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_ZS3V_100

	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 0 )
	{
		if ( next_state ==# 6 or ( ( next_state_rptr ==# 6 ) and h_g_p ) )
		{
			draw_state = 1;
			return;
		}

		return;
	}

	if ( this_state < 3 or ( ( next_state >=# this_state ) and not h_g_p ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state ==# 6 or ( ( next_state_rptr ==# 6 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_ZS6_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	enabled;
	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_inf;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf 	= next_sig_mr ( SIGFN_INFO );
	next_state_rptr = next_sig_lr ( SIGFN_INFO );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( next_state ==# 0 )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_inf ==# 1 or block_state() !=# BLOCK_CLEAR )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_inf ==# 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_ZS6_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	enabled;
	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_inf;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf 	= next_sig_mr ( SIGFN_INFO );
	next_state_rptr = next_sig_lr ( SIGFN_INFO );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( next_state ==# 0 )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_inf ==# 1 or block_state() !=# BLOCK_CLEAR )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_inf ==# 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT KS_ZS13

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	enabled;
	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_inf;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf 	= next_sig_mr ( SIGFN_INFO );
	next_state_rptr = next_sig_lr ( SIGFN_INFO );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( next_state ==# 1 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT LS

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		next_state;
	float		h_n_p;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );

	state = 7;
	draw_state = 0;

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		if ( block_state() !=# BLOCK_CLEAR )
		{
			state = 0;
			return;
		}	
	}
	else
	{
		if ( !enabled or block_state() !=# BLOCK_CLEAR )
		{
			state = 0;
			return;
		}
	}

	if ( h_n_p and next_state ==# 0 )
	{
		state = 0;
		return;
	}
	
	if ( speed_reduction > 0 )
	{
		state = speed_reduction;
		return;
	}

	if ( speed_reduction < 0 )
	{
		state = 0;
		draw_state = 0;
		return;
	}

	return;


SCRIPT LS_OPTIK_ROT

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 0 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT LS_OPTIK_WEISS1

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state > 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT LS_OPTIK_WEISS2

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state > 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_HP

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		cfgsig_mr;
	float		cfgsig_lr;
	float		next_state;
	float		h_n_p;
	float		next_state_rptr;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );

	state = 7;
	draw_state = 0;

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		if ( block_state() !=# BLOCK_CLEAR )
		{
			state = 0;
			draw_state = 0;
			return;
		}	
	}
	else
	{
		if ( !enabled or block_state() !=# BLOCK_CLEAR )
		{
			state = 0;
			draw_state = 0;
			return;
		}
	}

	if ( speed_reduction <=# 0 )
	{
		state = 0;
		return;	
	}

	if ( h_n_p and next_state ==# 0 )
	{
		state = 0;
		return;
	}

	if ( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 and next_state ==# 0 )
	{
		state = 0;
		return;	
	}
	
	if ( next_state ==# 1 and sig_feature ( SIGFEAT_USER2 ) )
	{
		state = 0;
		return;
	}

	if ( speed_reduction ==# 1 )
	{
		state = 1;
		return;	
	}
	
	if ( speed_reduction ==# 2 )
	{
		state = 2;
		return;	
	}

	if ( speed_reduction < 7 and speed_reduction > 2 )
	{	
		state = speed_reduction;
		return;
	}

	if ( speed_reduction ==# 7 or block_state ==# BLOCK_CLEAR )
	{
		state = 7;
		return;
	}

	if ( speed_reduction <=# 0 and ( sig_feature ( SIGFEAT_USER2 ) ) )
	{
		state = 1;
		return;
	}

	return;


SCRIPT HV_HP_OPTIK_ROT1

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_HP_OPTIK_ROT1_Z

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 1;
	return;


SCRIPT HV_HP_OPTIK_ROT2

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 0 and sig_feature ( SIGFEAT_USER3 ) )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# 0 and not sig_feature ( SIGFEAT_USER1 ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_HP_OPTIK_GELB

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( ( this_state > 2 ) and ( this_state < 5 ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_HP_OPTIK_GRUEN

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state > 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_HP_OPTIK_WEISS1

	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		h_g_p;
	float		next_state_rptr;
	float		next_state;
	float		this_state;
	
	h_g_p 		= sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_HP_OPTIK_WEISS2

	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		h_g_p;
	float		next_state_rptr;
	float		next_state;
	float		this_state;
	
	h_g_p 		= sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_HP_OPTIK_WEISS3

	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		h_g_p;
	float		next_state_rptr;
	float		next_state;
	float		this_state;
	
	h_g_p 		= sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 7 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_VR_OPTIK_GELB1

	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	debug_out ();

	float		h_g_p;
	float		next_state_rptr;
	float		next_state;
	float		this_state;
	float		cfgsig_mr;
	float		cfgsig_lr;
	
	next_state_rptr = next_sig_lr ( SIGFN_REPEATER );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );

	h_g_p = sig_feature ( SIGFEAT_GRADIENT_PLATE ) or 
			( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 );

	state = 7;
	draw_state = 0;

	if ( ( this_state < 3 ) and not ( this_state ==# -1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# -1 and ( ( next_state < 5 and not h_g_p ) or ( next_state_rptr < 5 and h_g_p ) ) )
	{
		draw_state = 1;
		return;
	}

	if ( ( next_state < 5 and not h_g_p ) or ( next_state_rptr < 5 and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_VR_OPTIK_GELB2

	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		h_g_p;
	float		next_state_rptr;
	float		next_state;
	float		this_state;
	float		cfgsig_mr;
	float		cfgsig_lr;
	
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );

	h_g_p = sig_feature ( SIGFEAT_GRADIENT_PLATE ) or 
			( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 );

	state = 7;
	draw_state = 0;

	if ( ( this_state < 3 ) and not ( this_state ==# -1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# -1 and ( ( next_state < 3 and not h_g_p ) or ( next_state_rptr < 3 and h_g_p ) ) )
	{
		draw_state = 1;
		return;
	}

	if ( ( next_state < 3 and not h_g_p ) or ( next_state_rptr < 3 and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_VR_OPTIK_GRUEN1

	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		h_g_p;
	float		next_state_rptr;
	float		next_state;
	float		this_state;
	float		cfgsig_mr;
	float		cfgsig_lr;
	
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );

	h_g_p = sig_feature ( SIGFEAT_GRADIENT_PLATE ) or 
			( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 );

	state = 7;
	draw_state = 0;

	if ( ( this_state < 3 ) and not ( this_state ==# -1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# -1 and ( ( next_state > 4 and not h_g_p ) or ( next_state_rptr > 4 and h_g_p ) ) )
	{
		draw_state = 1;
		return;
	}

	if ( ( next_state > 4 and not h_g_p ) or ( next_state_rptr > 4 and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_VR_OPTIK_GRUEN2

	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		h_g_p;
	float		next_state_rptr;
	float		next_state;
	float		this_state;
	float		cfgsig_mr;
	float		cfgsig_lr;
	
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );

	h_g_p = sig_feature ( SIGFEAT_GRADIENT_PLATE ) or 
			( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 );

	state = 7;
	draw_state = 0;

	if ( ( this_state < 3 ) and not ( this_state ==# -1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# -1 and ( ( next_state > 2 and not h_g_p ) or ( next_state_rptr > 2 and h_g_p ) ) )
	{
		draw_state = 1;
		return;
	}

	if ( ( next_state > 2 and not h_g_p ) or ( next_state_rptr > 2 and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_VR_OPTIK_WEISS_A

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		next_state_inf;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf	= next_sig_lr ( SIGFN_INFO );

	state = 7;
	draw_state = 0;

	if ( this_state < 0 )
	{
		if ( next_state_inf ==# 4 )
 		{
			draw_state = 1;
			return;
		}

		return;
	}

	if ( this_state < 3 and this_state >=# 0 )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_inf ==# 4 )
 	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HVK_VR_OPTIK_WEISS_A

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		next_state_inf;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf	= next_sig_lr ( SIGFN_INFO );

	state = 7;
	draw_state = 0;

	if ( this_state < 0 )
	{
		if ( next_state_inf ==# 4 )
 		{
			draw_state = 1;
			return;
		}

		return;
	}

	if ( this_state < 3 and this_state >=# 0 )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_inf ==# 4 )
 	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_VR_OPTIK_WEISS_B

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state	= next_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 1;
	return;


SCRIPT HV_ZS6

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	enabled;
	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_inf;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf 	= next_sig_mr ( SIGFN_INFO );
	next_state_rptr = next_sig_lr ( SIGFN_INFO );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( next_state ==# 0 )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_inf ==# 1 or block_state() !=# BLOCK_CLEAR )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_inf ==# 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_ZS8

	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		speed_reduction;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 1 and speed_reduction ==# 1 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_ZS1_ZS8_Z

	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		speed_reduction;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 0 )
	{
		draw_state = 0;
	}
	else
	{
		if ( this_state ==# 1 and speed_reduction ==# 1 )
		{
			draw_state = 2;
		}
		else
		{
			draw_state = 1;
		}
	}

	return;


SCRIPT HVK_ZS8

	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		speed_reduction;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 1 and speed_reduction ==# 1 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_ZS3_30_A

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	state;
	extern float	draw_state;

	float		cfgsig_mr;
	float		cfgsig_lr;
	float		next_state;
	float		h_n_p;
	float		next_state_rptr;

	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );

	if ( !enabled or block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
		draw_state = 0;
		return;
	}
	else
	{
		if ( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 )
		{
			state = 7;
			draw_state = 1;
			return;	
		}
	}

	return;


SCRIPT HV_ZS3V_30

	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_rptr;
	float		h_g_p;
	float		cfgsig_mr;
	float		cfgsig_lr;

	cfgsig_mr	= next_sig_mr ( SIGFN_SHUNTING );
	cfgsig_lr	= next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( cfgsig_mr !=# cfgsig_lr and cfgsig_mr ==# 0 and cfgsig_lr > 0 )
	{
		draw_state = 1;
		return;	
	}

	return;


SCRIPT HV_ZS3_60

	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# 4 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_ZS3V_60

	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 0 )
	{
		if ( next_state ==# 4 or ( ( next_state_rptr ==# 4 ) and h_g_p ) )
		{
			draw_state = 1;
			return;
		}

		return;
	}

	if ( this_state < 3 or ( ( next_state > this_state ) and not h_g_p ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state ==# 4 or ( ( next_state_rptr ==# 4 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_ZS3_80

	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# 5 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_ZS3V_80

	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 0 )
	{
		if ( next_state ==# 5 or ( ( next_state_rptr ==# 5 ) and h_g_p ) )
		{
			draw_state = 1;
			return;
		}

		return;
	}

	if ( this_state < 3 or ( ( next_state > this_state ) and not h_g_p ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state ==# 5 or ( ( next_state_rptr ==# 5 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_ZS3_100

	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( this_state ==# 6 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HV_ZS3V_100

	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_mr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 0 )
	{
		if ( next_state ==# 6 or ( ( next_state_rptr ==# 6 ) and h_g_p ) )
		{
			draw_state = 1;
			return;
		}

		return;
	}

	if ( this_state < 3 or ( ( next_state > this_state ) and not h_g_p ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state ==# 6 or ( ( next_state_rptr ==# 6 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_HP

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		next_state;
	float		next_state_dist;
	float		h_n_p;
	float		next_state_rptr;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_dist = next_sig_lr ( SIGFN_DISTANCE );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );

	state = 7;
	draw_state = 0;

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		if ( block_state() !=# BLOCK_CLEAR )
		{
			state = 0;
			return;
		}	
	}
	else
	{
		if ( !enabled or block_state() !=# BLOCK_CLEAR )
		{
			state = 0;
			return;
		}

	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		state = 1;
		draw_state = 0;
		return;	
	}

	if ( h_n_p and next_state ==# 0 )
	{
		state = 0;
		return;
	}
	
	if ( next_state ==# 1 and sig_feature ( SIGFEAT_USER2 ) )
	{
		state = 0;
		return;
	}

	if ( speed_reduction ==# 0 )
	{
		state = 0;
		return;
	}

	if ( speed_reduction ==# 1 )
	{
		state = 1;
		return;	
	}

	if ( speed_reduction ==# 2 or block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = 2;
		return;	
	}

	if ( ( speed_reduction > 2 ) and ( speed_reduction < 7 ) )
	{
		state = speed_reduction;
		return;
	}

	if ( speed_reduction ==# 7 or block_state ==# BLOCK_CLEAR )
	{
		state = 7;
		return;
	}

	if ( speed_reduction < 0 )
	{
		state = 0;
		return;
	}

	return;


SCRIPT FS_HP_A

	extern float	this_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 0;
	draw_state = 0;

	if ( this_state >=# 3 )
	{
		state = 7;
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_HP_A_B

	extern float	this_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 0;
	draw_state = 0;

	if ( this_state >=# 3 )
	{
		state = 7;
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_HP_B

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 0;
	draw_state = 0;

	if ( ( this_state > 2 ) and ( this_state < 6 ) )
	{
		state = 7;
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_HP_B_B

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 0;
	draw_state = 0;

	if ( ( this_state > 2 ) and ( this_state < 6 ) )
	{
		state = 7;
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_HP_C

	extern float	this_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 0;
	draw_state = 0;

	if ( this_state >=# 3 )
	{
		state = 7;
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_HP_D

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 0;
	draw_state = 0;

	if ( ( this_state > 2 ) and ( this_state < 6 ) )
	{
		state = 7;
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_VR_A

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;
	float		next_state_rptr;
	float		h_g_p;

	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( ( block_state() !=# BLOCK_CLEAR ) and sig_feature ( SIGFEAT_USER1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( ( next_state > 2 and not h_g_p ) or ( ( next_state_rptr > 2 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_VR_A_B

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;
	float		next_state_rptr;
	float		h_g_p;

	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 1;

	if ( ( block_state() !=# BLOCK_CLEAR ) and sig_feature ( SIGFEAT_USER1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( ( next_state < 5 and not h_g_p ) or ( ( next_state_rptr < 3 ) and h_g_p ) )
	{
		draw_state = 0;
		return;
	}

	return;


SCRIPT FS_VR_B

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;
	float		next_state_rptr;
	float		h_g_p;

	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( ( block_state() !=# BLOCK_CLEAR ) and sig_feature ( SIGFEAT_USER1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( ( next_state > 5 and not h_g_p ) or ( ( next_state_rptr > 5 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_VR_B_B

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;
	float		next_state_rptr;
	float		h_g_p;

	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 1;

	if ( ( block_state() !=# BLOCK_CLEAR ) and sig_feature ( SIGFEAT_USER1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( ( next_state < 3 and not h_g_p ) or ( ( next_state_rptr < 5 ) and h_g_p ) )
	{
		draw_state = 0;
		return;
	}

	return;


SCRIPT FS_VR_C

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;
	float		next_state_rptr;
	float		h_g_p;

	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( ( block_state() !=# BLOCK_CLEAR ) and sig_feature ( SIGFEAT_USER1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( ( next_state > 2 and not h_g_p ) or ( ( next_state_rptr > 2 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_VR_D

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;
	float		next_state_rptr;
	float		h_g_p;

	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( ( block_state() !=# BLOCK_CLEAR ) and sig_feature ( SIGFEAT_USER1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( ( next_state > 5 and not h_g_p ) or ( ( next_state_rptr > 5 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_VR_E

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;
	float		next_state_rptr;
	float		h_g_p;

	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( ( block_state() !=# BLOCK_CLEAR ) and sig_feature ( SIGFEAT_USER1 ) )
	{
		draw_state = 0;
		return;
	}

	if ( ( ( next_state < 6 and next_state > 2 ) and not h_g_p ) or 
		( ( next_state_rptr < 6 and next_state_rptr > 2 ) and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_HP_ZSX

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float		speed_reduction;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 0;
	draw_state = 0;

	if ( this_state ==# 1 )
	{
		state = 7;
		draw_state = 1;
		return;
	}

	return;


SCRIPT FS_HP_B_RA12

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 0;
	draw_state = 0;

	if ( this_state ==# 2 )
	{
		state = 7;
		draw_state = 1;
		return;
	}

	return;


SCRIPT GSP_F

	extern float	block_state ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	if ( !enabled or block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
	}
	else
	{
		state = 7;
	}

	draw_state = def_draw_state (state);

	return;


SCRIPT GSP_F_HP

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;

	next_state = next_sig_lr ( SIGFN_NORMAL );

	state = 7;

	if ( next_state ==# 0 )
	{
		state = 0;
	}

	draw_state = def_draw_state (state);

	return;

	
SCRIPT GSP_F_A

	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state ==# 0 )
	{
		state = 0;
	}
	else
	{
		state = 7;
	}

	draw_state = def_draw_state (state);

	return;


SCRIPT HL_HP

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		next_state;
	float		h_n_p;
	float		next_state_rptr;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );
	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );

	state = 7;

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		if ( block_state() !=# BLOCK_CLEAR )
		{
			state = 0;
			return;
		}	
	}
	else
	{
		if ( !enabled or block_state() !=# BLOCK_CLEAR )
		{
			state = 0;
			return;
		}

	}

	if ( h_n_p and next_state ==# 0 )
	{
		state = 0;
		return;
	}
	
	if ( next_state ==# 1 and sig_feature ( SIGFEAT_USER2 ) )
	{
		state = 0;
		return;
	}

	if ( speed_reduction ==# 0 )
	{	
		state = 0;
		return;
	}
	
	if ( speed_reduction < 0 or speed_reduction ==# 1 or speed_reduction ==# 5 )
	{	
		state = 1;
		return;
	}
	
	if ( speed_reduction ==# 2 )
	{
		state = 2;
		return;	
	}

	if ( speed_reduction < 7 and speed_reduction > 2 )
	{	
		state = speed_reduction;
		return;
	}

	return;


SCRIPT HL_HP_S

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		next_state;
	float		h_n_p;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );

	state = 1;

	if ( !enabled or block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
		return;
	}

	if ( h_n_p and next_state ==# 0 )
	{
		state = 0;
		return;
	}
	
	if ( next_state ==# 1 and sig_feature ( SIGFEAT_USER2 ) )
	{
		state = 0;
		return;
	}
	
	if ( speed_reduction < 0 )
	{	
		state = 1;
		return;
	}	

	if ( speed_reduction ==# 0 )
	{	
		state = 0;
		return;
	}
	
	if ( speed_reduction ==# 1 )
	{	
		state = 1;
		return;
	}
	
	if ( speed_reduction ==# 2 )
	{
		state = 2;
		return;	
	}

	return;


SCRIPT HL_HP_OPTIK_ROT

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HL_HP_OPTIK_GELB1

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state_rptr;
	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		h_g_p;

	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_g_p 		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		draw_state = 0;
		return;
	}
	
	if ( ( next_state < 3 and not h_g_p ) or ( next_state_rptr < 3 and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HL_HP_OPTIK_GELB2

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state_rptr;
	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		h_g_p;

	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_g_p 		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 7 and this_state > 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HL_HP_OPTIK_GRUEN

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state_rptr;
	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		h_g_p;

	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_g_p 		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( ( next_state ==# 7 and not h_g_p ) or 
		( next_state_rptr ==# 7 and h_g_p ) or sig_feature ( SIGFEAT_USER3 ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HL_HP_OPTIK_WEISS1

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HL_HP_OPTIK_WEISS2

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;
	float		next_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HL_HP_VRINFO

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state_rptr;
	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		h_g_p;

	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_g_p 		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( this_state < 3 )
	{
		draw_state = 0;
		return;
	}
	
	if ( ( ( next_state ==# 3 and not h_g_p ) or
		( next_state ==# 4 and not h_g_p ) ) or
		( ( next_state_rptr ==# 3 and h_g_p ) or
		( next_state_rptr ==# 4 and h_g_p ) ) )
	{
		draw_state = 1;
		return;
	}

	if ( ( next_state ==# 6 and not h_g_p ) or
		( next_state ==# 6 and not h_g_p ) )
	{
		draw_state = 2;
		return;
	}

	return;


SCRIPT HL_HP_LS

	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		speed_reduction;

	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	if ( this_state < 3 )
	{
		state = 0;
		draw_state = 0;
		return;
	}
	
	if ( this_state ==# 4 )
	{
		state = 7;
		draw_state = 1;
		return;
	}

	if ( this_state ==# 6 )
	{
		state = 7;
		draw_state = 2;
		return;
	}

	state = 0;
	draw_state = 0;

	return;


SCRIPT HL_VR_OPTIK_GELB

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state_rptr;
	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		h_g_p;

	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_g_p 		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( ( next_state < 3 and not h_g_p ) or ( next_state_rptr < 3 and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HL_VR_OPTIK_GRUEN

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state_rptr;
	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		h_g_p;

	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_g_p 		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( ( next_state ==# 7 and not h_g_p ) or ( next_state_rptr ==# 7 and h_g_p ) )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HL_VRINFO

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state_rptr;
	float		speed_reduction;
	float		this_state;
	float		next_state;
	float		h_g_p;

	next_state_rptr = next_sig_mr ( SIGFN_REPEATER );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_g_p 		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;
	
	if ( ( ( next_state ==# 3 and not h_g_p ) or
		( next_state ==# 4 and not h_g_p ) ) or
		( ( next_state_rptr ==# 3 and h_g_p ) or
		( next_state_rptr ==# 4 and h_g_p ) ) )
	{
		draw_state = 1;
		return;
	}

	if ( ( next_state ==# 6 and not h_g_p ) or
		( next_state ==# 6 and not h_g_p ) )
	{
		draw_state = 2;
		return;
	}

	return;


SCRIPT HL_ZS1_B

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;
	float		this_state;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );

	state = 7;
	draw_state = 0;

	if ( this_state ==# 0 )
	{
		draw_state = 0;
		return;
	}
	
	if ( this_state ==# 1 and speed_reduction !=# 5 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HL_ZS7

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	enabled;
	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_inf;
	float		next_state_rptr;
	float		h_g_p;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf 	= next_sig_mr ( SIGFN_INFO );
	next_state_rptr = next_sig_lr ( SIGFN_INFO );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );

	state = 7;
	draw_state = 0;

	if ( next_state_inf ==# 1 or next_state < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_inf ==# 2 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT HL_ZS8

	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;
	float		this_state;
	float		speed_reduction;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	this_state 	= this_sig_lr ( SIGFN_NORMAL );
	
	state = 0;
	draw_state = 0;	

	if ( next_state ==# 1 and speed_reduction ==# 1 )
	{
		state = 7;
		draw_state = 1;
		return;
	}	
	
	return;


SCRIPT HL_ZS13

	extern float	block_state ();
	extern float	route_set ();
	extern float	sig_feature ();
	extern float	this_sig_lr ();
	extern float	enabled;
	extern float	this_sig_mr ();
	extern float	next_sig_mr ();
	extern float	next_sig_lr ();
	extern float	state;
	extern float	draw_state;

	float		this_state;
	float 		next_state;
	float		next_state_inf;
	float		next_state_rptr;
	float		h_g_p;
	float		speed_reduction;

	this_state 	= this_sig_mr ( SIGFN_NORMAL );
	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	next_state_inf 	= next_sig_mr ( SIGFN_INFO );
	next_state_rptr = next_sig_lr ( SIGFN_INFO );
	h_g_p		= sig_feature ( SIGFEAT_GRADIENT_PLATE );
	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 7;
	draw_state = 0;

	if ( next_state ==# 1 )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT RA11X

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;
	float		h_n_p;

	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );

	if ( ( !enabled or block_state() !=# BLOCK_CLEAR ) or ( h_n_p and next_state ==# 0 ) )
	{
		state = 0;
	}
	else
	{
		state = 2;
	}

	draw_state = def_draw_state (state);

	return;


SCRIPT RA11AZ

	extern float	block_state ();
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	enabled;
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		next_state;
	float		h_n_p;

	next_state 	= next_sig_lr ( SIGFN_NORMAL );
	h_n_p		= sig_feature ( SIGFEAT_NUMBER_PLATE );

	if ( ( !enabled or block_state() !=# BLOCK_CLEAR ) or ( h_n_p and next_state ==# 0 ) )
	{
		state = 0;
		draw_state = 0;
		return;
	}
	else
	{
		state = 2;
		draw_state = 1;
		return;
	}


	return;


SCRIPT WNX

	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = 7;
	draw_state = 0;

	if ( route_set() )
	{
		draw_state = 1;
		return;
	}

	return;


SCRIPT BUE1

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = 7;
	draw_state = def_draw_state (state);

	return;


SCRIPT SH0

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = 1;
	draw_state = def_draw_state (state);
	return;


SCRIPT SH2

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = 1;
	draw_state = def_draw_state (state);
	return;


SCRIPT CONFIG_ZS6_A

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = 1;
	draw_state = def_draw_state (state);
	return;


SCRIPT CONFIG_ZS6_B

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = 2;
	draw_state = def_draw_state (state);
	return;


SCRIPT CONFIG_VKB_A

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = 3;
	draw_state = def_draw_state (state);
	return;


SCRIPT CONFIG_VKB_B

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = 4;
	draw_state = def_draw_state (state);
	return;


SCRIPT S_R

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = 7;
	draw_state = def_draw_state (state);
	return;


SCRIPT S_R_H

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = 0;
	draw_state = def_draw_state (state);
	return;


SCRIPT S_R_Z

	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 1;

	if ( sig_feature ( SIGFEAT_USER1 ) and ( speed_reduction < state ) )
	{
		state = speed_reduction;
	}

	draw_state = def_draw_state (state);
	return;


SCRIPT S_R_R

	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 2;

	if ( sig_feature ( SIGFEAT_USER1 ) and ( speed_reduction < state ) )
	{
		state = speed_reduction;
	}

	draw_state = def_draw_state (state);
	return;


SCRIPT S_R_40

	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 3;

	if ( sig_feature ( SIGFEAT_USER1 ) and ( speed_reduction < state ) )
	{
		state = speed_reduction;
	}

	draw_state = def_draw_state (state);
	return;


SCRIPT S_R_60

	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 4;

	if ( sig_feature ( SIGFEAT_USER1 ) and ( speed_reduction < state ) )
	{
		state = speed_reduction;
	}

	draw_state = def_draw_state (state);
	return;


SCRIPT S_R_80

	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 5;

	if ( sig_feature ( SIGFEAT_USER1 ) and ( speed_reduction < state ) )
	{
		state = speed_reduction;
	}

	draw_state = def_draw_state (state);
	return;


SCRIPT S_R_100

	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 6;

	if ( sig_feature ( SIGFEAT_USER1 ) and ( speed_reduction < state ) )
	{
		state = speed_reduction;
	}

	draw_state = def_draw_state (state);
	return;


SCRIPT S_R_VMAX

	extern float	sig_feature ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	state = 7;

	if ( sig_feature ( SIGFEAT_USER1 ) and ( speed_reduction < state ) )
	{
		state = speed_reduction;
	}

	draw_state = def_draw_state (state);
	return;


SCRIPT VMAX

	extern float	next_sig_lr ();
	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	enabled ();
	extern float	state;
	extern float	draw_state;

	float		speed_reduction;

	speed_reduction = next_sig_lr ( SIGFN_SHUNTING );

	if ( !enabled or block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
	}
	else
	{
		if ( sig_feature ( SIGFEAT_USER1 ) and not speed_reduction < 3 )
		{
			state = speed_reduction;
			draw_state = def_draw_state (state);
			return;
		}

		state = 7;
	}

	draw_state = def_draw_state (state);
	return;


SCRIPT VMAX_CONFIG

	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	debug_out ();

	float		next_state;
	float		this_state;

	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	
	state = 7;

	if ( next_state < 3 )
	{
		state = 1;
		draw_state = def_draw_state (state);
	}
	
	if ( next_state < 7 and next_state > 2 )
	{
		state = next_state;
		draw_state = def_draw_state (state);
		return;
	}
	
	draw_state = def_draw_state (state);
	return;
	
	
////////////////////////////////////////////////////////////////////////////////
//         SCRIPTS CHE ETCS2-Signale			                              //
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
SCRIPT CHEKennungETCS2Normal

	extern float	state;
		
		state = SIGASP_CLEAR_1;


SCRIPT ChEMerktafelHauptsignal_LN-ETCS2
// CHE Merktafel Hauptsignal LN-ETCS2
// Steht immer als erstes Signal einer ETCS2-Strecke
// Nach vorn erlaubt es hchsten Vmax 140 damit die Warnfunktion des dahinterstehenden Signal korrekt funktioniert
	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature();
	float			next_state;
	float			next_kenn;

		next_state = next_sig_lr (SIGFN_NORMAL);
		next_kenn  = next_sig_lr (SIGFN_REPEATER);

	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP;				// Stop, Warnung am davostehenden N-Signal
	}
	else if ( next_kenn ==# SIGASP_CLEAR_1 ) 		// es folgt eine ETCS2_Signal 
	{
		if (next_state ==# SIGASP_STOP )		// nchstes ETCS2-Signal zeigt Stop
		{
			state = SIGASP_APPROACH_3;		// dieses zeigt 90 km/h, Warnung 90 am davorstehenden N-Signal
		}
		else if (next_state ==# SIGASP_APPROACH_1 )	// Nchstes ETCS2-Signal zeigt 100km/h
		{
			state = SIGASP_CLEAR_1;			// dieses zeigt 140 km/h, freie Fahrt am davorstehnden N-Signal
		}
		else if (next_state ==# SIGASP_APPROACH_2 )	// Nchstes ETCS2-Signal zeigt 140km/h
		{
			state = SIGASP_CLEAR_1;			// dieses zeigt 140 km/h, freie Fahrt am davorstehnden N-Signal
		}
		else							// Nchstes ETCS2-Signal zeigt 160km/h, 170km/h oder 200 km/h
		{
			state = SIGASP_CLEAR_2;				// dieses zeigt 200, freie Fahrt am davorstehnden N-Signal
		}
	}
	else 
	{								
			state = SIGASP_CLEAR_2;			// soll nicht vorkommen
	}
	
///////////////////////////////////////////////////////////////////////////////
SCRIPT ChEMerktafelHauptsignal
// CHE Merktafel Hauptsignal
	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature();
	float			next_state;
	float			next_kenn;

		next_state = next_sig_lr (SIGFN_NORMAL);
		next_kenn  = next_sig_lr (SIGFN_REPEATER);

	if (!route_set())
	{
		state = SIGASP_STOP;
	}
	else if (!enabled || block_state() !=# BLOCK_CLEAR )
	{								
		if (block_state() ==# BLOCK_CLEAR )		//Wenn dieses Signal noch nicht "enabled" ist, aber der Block voraus frei ist, 	
		{							//wird "STOP_AND_PROCEED" gesetzt
			state = SIGASP_STOP_AND_PROCEED;	//damit das davorstehende "APPROACH_3 statt "APPROACH_2 setzen kann
		}							//So kann 	"SignalNumClearAhead ( 3 )" unverndert bleiben 
		else
		{
			state = SIGASP_STOP;
		}
	}
// Signal is enabled and the block ahead is clear
	else if ( next_kenn ==# SIGASP_CLEAR_1 ) 			//es folgt eine ETCS2_Signal 
	{
		if (next_state ==# SIGASP_STOP )			// nchstes zeigt Stop und strecke dahinter ist belegt
		{
			state = SIGASP_APPROACH_1;			// dieses zeigt Vmax 100
		}
		else if (next_state ==# SIGASP_APPROACH_1 || next_state ==# SIGASP_STOP_AND_PROCEED ) // nchstes zeigt 100 od. Stop mit Strecke dahinter frei
		{
			state = SIGASP_APPROACH_2;			// dieses zeigt Vmax 140
		}
		else if (next_state ==# SIGASP_APPROACH_2 ) 	// nchstes zeigt Vmax 140 
		{
			state = SIGASP_CLEAR_1;	 			// dieses zeigt Vmax 170
		}
		else								// nchstes zeigt 160 APPROACH_3, 170 CLEAR_1 oder 200 CLEAR_2
		{
		state = SIGASP_CLEAR_2;					// dieses zeigt Vmax 200
		}
	}
	else if ( next_kenn ==# SIGASP_APPROACH_3 ) 			//es folgt ein L/N-Vorsignal oder eine Signalfolgeende Marke
	{								
			if (sig_feature(SIGFEAT_USER2)  )
			{
				state = SIGASP_APPROACH_3;		// dieses zeigt Vmax 160 Streckengeschwindigkeit
			}
			else 
			{
				state = SIGASP_APPROACH_2;		// dieses zeigt Vmax 140 Streckengeschwindigkeit
			}
	}
	else 									//es folgt ein L/N-SignalHauptsignal
	{								
		if (next_state >=# SIGASP_STOP && next_state <=# SIGASP_APPROACH_2  ) 	// nchstes zeigt Stop bis Vmax 60 km/h
		{
			state = SIGASP_APPROACH_1;							// Dieses zeigt 100 km/h
		}
		else if (next_state ==# SIGASP_APPROACH_3 )					// Nchstes zeigt 90 km/h
		{
			state = SIGASP_APPROACH_2;							// Dieses zeigt 140 km/h
		}
		else	if (sig_feature(SIGFEAT_USER2)  )						// Vmax LN ist auf 160 km/h erhht
		{
			state = SIGASP_APPROACH_3;							// dieses zeigt Vmax 160 km/h
		}
		else
		{
			state = SIGASP_APPROACH_2;							// dieses zeigt 140 km/h
		}

	}
