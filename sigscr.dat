//////////////////////////////////////////////////////////////////////////
//	Danish Signal configuration file 				//
//	This file may be redistributed 					//
//									//
//	Rel. 4.0   							//
//	Copyright:							//
//	Team RouteBuilders DK						//
//	Stig Christensen  27-06-2003					//
//////////////////////////////////////////////////////////////////////////



SCRIPT KBSemRoute
// dk TU armsignal

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!enabled || block_state() ==# BLOCK_JN_OBSTRUCTED )
	
	{
		state = SIGASP_STOP;
	}
	else if ( next_state ==# SIGASP_CLEAR_1 || next_state==# SIGASP_CLEAR_2 )							 
	{
		state = SIGASP_CLEAR_2;
	}
	else if (next_state ==# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	else 
	{
		state = SIGASP_STOP;
	}	

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT KBSemDist
//nyt Script som tager hoejde for foer / efter 1961

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	float		next_state;
	float		Efter_61;

	Efter_61 = sig_feature (SIGFEAT_USER1);
	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( Efter_61 )
	{
//  Efter 1961
		if ( next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			state = SIGASP_APPROACH_2;
		}

	}
	else
	{
//  foer 1961
		if ( next_state ==# SIGASP_STOP ) 
		{
			state = SIGASP_APPROACH_2;
		}
		else
		{
			state = SIGASP_CLEAR_2;
		}
	}
// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT KBSemMain

// Kystbanen Semaphore Signal Main, main arm
	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}


// Get draw state
	draw_state = def_draw_state (state);
//////////////////////////////////////////////////////////////////////////////////////

SCRIPT KBSemEntryHead1

// Kystbanen Semaphore Signal Entry, main arm

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				state = SIGASP_CLEAR_1;
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);


//////////////////////////////////////////////////////////////////////////////////////
SCRIPT KBSemEntryHead2

// Kystbanen Semaphore Signal Entry, entry arm
// When down/yellow: slow speed
// When up/green:    go through

	extern float	this_sig_lr ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);
	state = SIGASP_STOP;
	if (this_state ==# SIGASP_CLEAR_2)

	{
	state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);
//////////////////////////////////////////////////////////////////////////////////////

SCRIPT dk-vmdvsig

// dk Dvaerg signal head

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();


// If required, show the 'stop' indication.

	if (!enabled ) 
	{
		state = SIGASP_STOP;
	}

	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED ) 
	// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else 
	{
	
		state = SIGASP_APPROACH_3;
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dk-vmpusig

// dk platform signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if ( !enabled )
	{
		state = SIGASP_RESTRICTING;
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_APPROACH_3;
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkam
// dkam signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		VD;


	VD = sig_feature (SIGFEAT_USER1);
	next_state = next_sig_lr (SIGFN_NORMAL);

	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( enabled ) 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 || next_state ==# SIGASP_APPROACH_3)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			state = SIGASP_CLEAR_1;
		}
	}
	else
	{
		if ( VD )	
		{
			state = SIGASP_STOP;
		}
		else 
		{
			state = SIGASP_RESTRICTING;
		}

	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dkamsbane
// dk am signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;



	next_state = next_sig_lr (SIGFN_NORMAL);

	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( !enabled ) 
	{
		state = SIGASP_RESTRICTING;
	}
	else 
	{
	if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 || next_state ==# SIGASP_APPROACH_3)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			state = SIGASP_CLEAR_1;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk2udsbane
// dk  ud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SU;


	SU = sig_feature (SIGFEAT_USER1);


// If required, show the 'stop' indication.
	if ( !route_set ()|| !enabled || block_state() !=# BLOCK_CLEAR )
	// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 ||
			next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			if ( SU )
			{
				state = SIGASP_APPROACH_3;
			}
			else
			{
				state = SIGASP_CLEAR_1;
			}
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dk2ud
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk3ud
// dk ud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SU;


	SU = sig_feature (SIGFEAT_USER1);



	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else 
	{
	if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			if ( SU )
			{
				state = SIGASP_APPROACH_3;
			}
			else
			{
				state = SIGASP_CLEAR_1;
			}
		}
	}

// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4ind

// dkind signal head 4 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4ind_old

// dkind signal head 4 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT dk1distant

// Dk distant signal

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	state = SIGASP_APPROACH_2;

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dk2distant

// Dk distant signal

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);

	state = SIGASP_APPROACH_2;
	if (next_state ==# SIGASP_CLEAR_1 ||
		next_state ==# SIGASP_CLEAR_2) 
	{
		state = SIGASP_CLEAR_1;
	}
// Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////////
SCRIPT dk3distant

// Dk distant signal

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	next_state = next_sig_lr (SIGFN_INFO);

	state = SIGASP_APPROACH_2;
	if (next_state ==# SIGASP_CLEAR_1) 
	{
		state = SIGASP_CLEAR_1;
	}

	else if (next_state ==# SIGASP_CLEAR_2) 

	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dktusig
// dk TU signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!enabled || block_state() ==# BLOCK_JN_OBSTRUCTED )
	
	{
		state = SIGASP_STOP;
	}
	else if ( next_state ==# SIGASP_CLEAR_1 || next_state==# SIGASP_CLEAR_2 )							 
	{
		state = SIGASP_CLEAR_2;
	}
	else if (next_state ==# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	else 
	{
		state = SIGASP_STOP;
	}	

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkunsecskilt
// dk unsecure area follows

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

		state = SIGASP_APPROACH_1;


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkstopskilt
// dk STOP SIGN

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

		state = SIGASP_STOP;


// Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////////




SCRIPT dk-dvsig

// dk Dvaerg signal head

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		rangerspor;


	rangerspor = sig_feature (SIGFEAT_USER1);

// If required, show the 'stop' indication.

	if (!enabled ) 
	{
		if ( rangerspor ) 
		{		
			state = SIGASP_STOP_AND_PROCEED;
		}
		else	
		{
			state = SIGASP_STOP;
		}
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED ) 
	// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else 
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);
		state = SIGASP_RESTRICTING;

		if (next_state ==# SIGASP_APPROACH_1 || next_state ==# SIGASP_RESTRICTING ) 
		{
			state = SIGASP_APPROACH_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_2; 
		}
		else if(next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_APPROACH_3;
		}
		else if(next_state ==# SIGASP_CLEAR_1)
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk5indv

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT left_arm

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 
			state = SIGASP_APPROACH_3;
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT dk6indv

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Left_arm_g

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);



// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);




///////////////////////////////////////////////////////////////////////////////

SCRIPT dk5indh

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 

			state = SIGASP_APPROACH_3;

		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk6indh

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm_g

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);


// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);




///////////////////////////////////////////////////////////////////////////////

SCRIPT dkhviser

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		wait;
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		Diverte_route_40;
	float		SI_ahead;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);
	Diverte_route_40 = sig_feature (SIGFEAT_USER4);
	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);

	this_state = this_sig_lr(SIGFN_INFO);
	next_state = next_sig_lr(SIGFN_NORMAL);


if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1 )
		{	
			if ( Diverte_route_40 )
			{
				state = SIGASP_APPROACH_1;
			}
			else
			{
				state = SIGASP_APPROACH_2;
			}
		}

	else if (this_state ==# SIGASP_CLEAR_1 || this_state ==# SIGASP_CLEAR_2)
		{
			if (Main_track_40)
			{
				state = SIGASP_APPROACH_1;
			}
			else if (Main_track_60)
			{
				state = SIGASP_APPROACH_2;
			}
			else
			{
				state = SIGASP_CLEAR_1;
				if (SI_ahead &&
 (next_state !=# SIGASP_CLEAR_1 && next_state !=# SIGASP_CLEAR_2 && next_state !=# SIGASP_APPROACH_3))
				{
					state = SIGASP_APPROACH_3;
				}

			}
		}
		else if (this_state ==# SIGASP_APPROACH_3 )
		{	
			if ( Side_track_40 || !route_set() )
			{
				state = SIGASP_APPROACH_1;
			}
			else
			{
				state = SIGASP_APPROACH_2;
			}
		}
		else if (this_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_1;
		}
		else
		{
			state = SIGASP_STOP;
		}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dk3ind_old

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		if (route_set() )
			{
				state = SIGASP_CLEAR_1;
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		else
		{
			state = SIGASP_APPROACH_3;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dk3ind

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		if (route_set() )
			{
				state = SIGASP_CLEAR_1;
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		else
		{
			state = SIGASP_APPROACH_3;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dkvisig

// dk platform signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if ( !enabled )
	{
		state = SIGASP_RESTRICTING;
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_APPROACH_1;
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dkvusig

// dk platform signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if ( !enabled )
	{
		state = SIGASP_RESTRICTING;
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_APPROACH_3;
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dkpusig

// dk platform signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
if (block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	else if (!enabled || block_state() ==# BLOCK_OCCUPIED ) 		// Block ahead not clear?
									
	{
		state = SIGASP_RESTRICTING;
	}
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP )
		{
			state = SIGASP_RESTRICTING;
		}
		else if (next_state ==# SIGASP_APPROACH_1 || next_state ==# SIGASP_RESTRICTING) 
		{
			state = SIGASP_APPROACH_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_2; 
		}
		else if(next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_APPROACH_3;
		}
		else
		{
			state = SIGASP_CLEAR_2;
		}

	}


// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_2udsighkt

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	extern float	route_set ();
	float		next_state;

// If required, show the 'stop' indication.
	 if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED)
 	// Block ahead not clear?
									
	{
		state = SIGASP_STOP;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dkhktblok

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication.
	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( !enabled ) 
	{
		state = SIGASP_RESTRICTING;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_amsighkt

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication.
	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( !enabled ) 
	{
		state = SIGASP_RESTRICTING;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dkindhkt

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;
	float		Main_track_70;
	float		Main_track_50;
	float		Side_track_70;
	float		Side_track_50;

	Main_track_70 = sig_feature (SIGFEAT_USER1);
	Main_track_50 = sig_feature (SIGFEAT_USER2);
	Side_track_70 = sig_feature (SIGFEAT_USER3);
	Side_track_50 = sig_feature (SIGFEAT_USER4);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		state = SIGASP_APPROACH_1;

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if (next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if (next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
	}
	if (route_set() && Main_track_70 && state >=# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	if (route_set() && Main_track_50 && state >=# SIGASP_APPROACH_2 )
	{
		state = SIGASP_APPROACH_2;
	}
	if (!route_set() && Side_track_70 && state >=# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	if (!route_set() && Side_track_50 && state >=# SIGASP_APPROACH_2 )
	{
		state = SIGASP_APPROACH_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkpusighkt

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication.
	 if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED)
 	// Block ahead not clear?
									
	{
		state = SIGASP_STOP;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dk-dvsighkt

// dk Dvaerg signal head

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		rangerspor;


	rangerspor = sig_feature (SIGFEAT_USER1);

// If required, show the 'stop' indication.

	if (!enabled ) 
	{
		if ( rangerspor ) 
		{		
			state = SIGASP_STOP_AND_PROCEED;
		}
		else	
		{
			state = SIGASP_STOP;
		}
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED ) 
	// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else 
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);
		state = SIGASP_RESTRICTING;

		if ( next_state ==# SIGASP_RESTRICTING ) 
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1  ) 
		{
			state = SIGASP_APPROACH_2;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_bogvis_A
// dk bogstavsviser A

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show A
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_B
// dk bogstavsviser B

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show B
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_C
// dk bogstavsviser C

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show C
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_D
// dk bogstavsviser D

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show D
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_E
// dk bogstavsviser E

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show E
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_F
// dk bogstavsviser F

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show F
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);
//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_G
// dk bogstavsviser G

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show G
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////

SCRIPT dk_bogvis_H
// dk bogstavsviser H

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show H
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_K
// dk bogstavsviser K

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show K
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_L
// dk bogstavsviser L

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show L
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_M
// dk bogstavsviser M

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show M
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_N
// dk bogstavsviser N

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show N
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_O
// dk bogstavsviser O

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show O
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_P
// dk bogstavsviser P

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show P
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_R
// dk bogstavsviser R

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show R
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_S
// dk bogstavsviser S

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show S
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_T
// dk bogstavsviser T

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal = sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show G
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_U
// dk bogstavsviser U

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal = sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show U
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_V
// dk bogstavsviser V

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal = sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 || (this_state !=# SIGASP_STOP && is_HKT_signal) )
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show V
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_OE
// dk bogstavsviser OE

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show OE
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////

SCRIPT dk_retviser_L
// dk Retningsviser Left

	extern float	route_set ();
	extern float	this_sig_mr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state = this_sig_mr (SIGFN_NORMAL);
	state = SIGASP_STOP;

	if (this_state !=# SIGASP_STOP)
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show Left
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);
	

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_retviser_R
// dk Retningsviser Right

	extern float	route_set ();
	extern float	this_sig_mr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state = this_sig_mr (SIGFN_NORMAL);
	state = SIGASP_STOP;

	if (this_state !=# SIGASP_STOP)
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show Right
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver7sig
// dk Aktiver 7 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver9sig
// dk Aktiver 9 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver11sig
// dk Aktiver 11 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver13sig
// dk Aktiver 13 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver15sig
// dk Aktiver 15 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver17sig
// dk Aktiver 17 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver19sig
// dk Aktiver 19 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT KBsig_Point

// Sporskiftesignal

	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	if ( route_set() )		// Switch set as per link (straight branch)?
	{
		state = SIGASP_CLEAR_2;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed30

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		wait;
	float		next_state;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);
	next_state = next_sig_lr(SIGFN_NORMAL);


if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}




// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed40

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed50

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed60

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4indv_old

// dkind signal head 4 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
//		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			SI_state = next_sig_lr (SIGFN_INFO);
			state = SIGASP_CLEAR_1;
			if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
			{
				state = SIGASP_CLEAR_2;
			} 
			else
			{
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT dk5indv_old

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT left_arm_old

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 
			state = SIGASP_APPROACH_3;
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT dk6indv_old

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Left_arm_g_old

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);



// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4indh_old

// dkind signal head 4 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
//		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
		
			SI_state = next_sig_lr (SIGFN_INFO);
			state = SIGASP_CLEAR_1;
			if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
			{
				state = SIGASP_CLEAR_2;
			} 
			else
			{
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);



///////////////////////////////////////////////////////////////////////////////

SCRIPT dk5indh_old

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm_old

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 

			state = SIGASP_APPROACH_3;

		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk6indh_old

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm_g_old

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);


// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT dktusig_bag
// dk TU signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

	state = this_sig_lr (SIGFN_NORMAL);

//	if (!enabled || block_state() ==# BLOCK_JN_OBSTRUCTED )
//	
//	{
//		state = SIGASP_STOP;
//	}
//	else if ( next_state ==# SIGASP_CLEAR_1 || next_state==# SIGASP_CLEAR_2 )							 
//	{
//		state = SIGASP_CLEAR_2;
//	}
//	else if (next_state ==# SIGASP_APPROACH_3 )
//	{
//		state = SIGASP_APPROACH_3;
//	}
//	else 
//	{
//		state = SIGASP_STOP;
//	}	

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivind

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		if ( route_set() )
			{
				state = SIGASP_CLEAR_1;
			}
		else
		{
			state = SIGASP_APPROACH_3;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dkprivud
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// If required, show the 'stop' indication.
	if ( route_set () && enabled && block_state() ==# BLOCK_CLEAR )	// Block ahead not clear?
							 
	{
		state = SIGASP_CLEAR_2;
	}
	else
	{
		state = SIGASP_STOP;	
	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivud2
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	opp_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication

		state = next_sig_lr ( SIGFN_INFO );


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivper
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;
	float		sidespor;


	sidespor = sig_feature ( SIGFEAT_USER1 );

	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( route_set () && enabled && block_state() !=# BLOCK_JN_OBSTRUCTED && next_state ==# SIGASP_CLEAR_2 )
	// Block ahead not clear?
	{
		if ( sidespor )
			{
				state = SIGASP_APPROACH_3;
			}
		else
			{
				state = SIGASP_CLEAR_2;
			}
	}
	else
	{
			state = SIGASP_STOP;
	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivper2
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		sidespor;

	sidespor = sig_feature ( SIGFEAT_USER1 );

// If required, show the 'stop' indication.
	if ( sidespor )	// Block ahead not clear?
							 
	{
		state = SIGASP_APPROACH_3;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
// BeeKay Signal Type Logic Script   Hp, HV & Ks   Version 4.1a       14.09.2003
// Dipl.Ing.(FH) Bernd K. Diehl berndkdiehl@freenet.de
///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_Block

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_CLEAR_2;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_Ein

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{


	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else
	{
		if ( !route_set () )
			{
			state = SIGASP_APPROACH_2;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_Aus

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{


	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_CLEAR_2;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_Aus40

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_APPROACH_1;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_Aus40R

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_RESTRICTING;
		}
	else 
	{
		state = SIGASP_APPROACH_1;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_AusV_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_CLEAR_2;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_AusV_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP_AND_PROCEED;
			}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_Aus40V_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_APPROACH_1;
	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_Aus40V_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP_AND_PROCEED;
			}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_Vw_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	state = SIGASP_CLEAR_2;
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_Li_DB_Gsp

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			next_state;
	float			this_state;

	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	}
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Bue

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Haupt_Vmax

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_CLEAR_2;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Haupt_100

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_APPROACH_3;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Haupt_100_3

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_3;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED || this_state !=# SIGASP_APPROACH_3 )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Haupt_60

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_APPROACH_2;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Haupt_60_3

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_2;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED || this_state !=# SIGASP_APPROACH_2 )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Haupt_40

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_APPROACH_1;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_40w_Haupt_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else
	{
		if ( !route_set () )
			{
			state = SIGASP_APPROACH_1;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}

	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_60w_Haupt_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else
	{
		if ( !route_set () )
			{
			state = SIGASP_APPROACH_2;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_60w_Haupt_3

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else
		{
		state = SIGASP_APPROACH_2;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED || this_state !=# SIGASP_APPROACH_2 )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_DB_1Flg_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR || !route_set() )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_CLEAR_2;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_DB_2Flg_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR || !route_set() )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_DB_2Flg_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR || !route_set() )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_DB_Einfahr_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_APPROACH_1;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_DB_Einfahr_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	state = this_state;

	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Vr_DB_1Flg_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Vr_DB_2Flg_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Vr_DB_2Flg_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Normal_60w_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			this_state_dist;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	this_state_dist = this_sig_lr ( SIGFN_DISTANCE );        

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_APPROACH_2;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
//////////////	if ( this_state_dist !=# SIGASP_CLEAR_2 )
//////////////		{
//////////////		state = SIGASP_CLEAR_1;
//////////////		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}


	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Normal_60w_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Normal_60w_3

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_2;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED || this_state !=# SIGASP_APPROACH_2 )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_F_Box_sp

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_CLEAR_2;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ra10_sp

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_CLEAR_2;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_40_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_40_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_40_Ra12_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP_AND_PROCEED;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP_AND_PROCEED;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_40_Ra12_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_40_Zs1_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_RESTRICTING;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_RESTRICTING;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_40_Zs1_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Ausfahr_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_CLEAR_2;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_Ausfahr_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_60_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_2;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_60_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_60_3

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_2;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_100_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_3;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_100_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_100_3

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_3;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_V

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Gsp_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			next_state;
	float			this_state;

	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Sh2_sp

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;


	state = SIGASP_STOP;

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ra11a

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			next_state;
	float			this_state;

	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	}
	draw_state = def_draw_state (state);



///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_WeiLa

	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			next_state;

	if ( route_set() )
		{
		state = SIGASP_CLEAR_2;
		}
	else
		{
		state = SIGASP_APPROACH_1;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ra11a_Zwerg

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			next_state;
	float			this_state;

	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_40_Hv_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR || next_state !=# SIGASP_CLEAR_2 )
		{
		state = SIGASP_STOP;
		}
	else
		{
		state = SIGASP_APPROACH_1;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_60_Hv_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR || next_state !=# SIGASP_CLEAR_2 )
		{
		state = SIGASP_STOP;
		}
	else
		{
		state = SIGASP_APPROACH_2;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hl_60_Hv_3

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR || next_state !=# SIGASP_CLEAR_2 )
		{
		state = SIGASP_STOP;
		}
	else
		{
		state = SIGASP_APPROACH_2;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED || this_state !=# SIGASP_APPROACH_2 )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_PKP_40_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_PKP_40_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_PKP_Ausfahr_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_CLEAR_2;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_PKP_Ausfahr_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_PKP_Einfahr_1

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_APPROACH_1;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_PKP_Einfahr_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Zp9

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING || block_state() ==# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else
		{
		state = SIGASP_CLEAR_2;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}	

	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Sv_V

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Sv_01

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_CLEAR_2;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Sv_02

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_APPROACH_1;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_2;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_3;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_CLEAR_1;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}


	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Sv_03

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
		{
		state = SIGASP_STOP;
		}
	else
		{
		state = SIGASP_CLEAR_2;
		}


	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Sv_40_01

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_A

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_CLEAR_2;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_A_V

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP_AND_PROCEED;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
						if ( next_state ==# SIGASP_CLEAR_1 )
							{
							state = SIGASP_CLEAR_1;
							}

						else
							{
							state = SIGASP_CLEAR_2;
							}
					}
				}
			}
		}
		if ( next_state >= this_state )
			{
			state = SIGASP_RESTRICTING;
			}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_A_H

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	state = this_state;

	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_A40

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_A60

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_2;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_A80

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_3;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_A100

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_CLEAR_1;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_E40

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_APPROACH_1;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_E60

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_APPROACH_2;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_E80

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_APPROACH_3;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_E100

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_CLEAR_1;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_A_Vv

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP_AND_PROCEED;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
						if ( next_state ==# SIGASP_CLEAR_1 )
							{
							state = SIGASP_CLEAR_1;
							}

						else
							{
							state = SIGASP_CLEAR_2;
							}
					}
				}
			}
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_A_Vw

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP_AND_PROCEED;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
						if ( next_state ==# SIGASP_CLEAR_1 )
							{
							state = SIGASP_CLEAR_1;
							}

						else
							{
							state = SIGASP_CLEAR_2;
							}
					}
				}
			}
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_HA

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_CLEAR_2;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_HA40

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_1;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_HA60

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_2;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_HA80

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_APPROACH_3;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_HA100

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
		{
		state = SIGASP_CLEAR_1;
		}

	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_HE40

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_APPROACH_1;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_HE60

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_APPROACH_2;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_HE80

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_APPROACH_3;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Ks_HE100

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		if ( !route_set() )
			{
			state = SIGASP_CLEAR_1;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_kompakt_Aus

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{


	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_CLEAR_2;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_kompakt_V

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP_AND_PROCEED;
			}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_kompakt_Aus40

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{

	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_APPROACH_1;
	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_kompakt_Vw

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
					state = SIGASP_CLEAR_2;
					}
				}
			}
		}
		if ( this_state ==# SIGASP_STOP || this_state ==# SIGASP_STOP_AND_PROCEED || this_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP_AND_PROCEED;
			}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_kompakt_Block

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );


	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{


	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else 
	{
		state = SIGASP_CLEAR_2;

	}
	if ( block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Hp_kompakt_Ein

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

	if ( !enabled )
		{
		state = SIGASP_STOP;
		}
	else 
	{


	if ( block_state() !=# BLOCK_CLEAR )
		{
		state = SIGASP_STOP;
		}
	else
	{
		if ( !route_set () )
			{
			state = SIGASP_APPROACH_2;
			}
		else
			{
			state = SIGASP_CLEAR_2;
			}

	}
	}

	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Anschluss

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP_AND_PROCEED;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
						if ( next_state ==# SIGASP_CLEAR_1 )
							{
							state = SIGASP_CLEAR_1;
							}

						else
							{
							state = SIGASP_CLEAR_2;
							}
					}
				}
			}
		}
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BK_Zp9_Ring

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	next_sig_mr ();
	extern float	sig_feature ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float			has_number_plate;
	float			has_gradient_plate;
	float			next_state;
	float			this_state;
	float			next_state_mr;

	has_number_plate   = sig_feature ( SIGFEAT_NUMBER_PLATE );
	has_gradient_plate = sig_feature ( SIGFEAT_GRADIENT_PLATE );
	next_state = next_sig_lr ( SIGFN_NORMAL );
	this_state = this_sig_lr ( SIGFN_NORMAL );
	next_state_mr = next_sig_mr ( SIGFN_NORMAL );

		if ( next_state ==# SIGASP_STOP || next_state ==# SIGASP_STOP_AND_PROCEED || next_state ==# SIGASP_RESTRICTING )
			{
			state = SIGASP_STOP_AND_PROCEED;
			}
		else
		{
			if ( next_state ==# SIGASP_APPROACH_1 )
				{
				state = SIGASP_APPROACH_1;
				}
			else
			{
				if ( next_state ==# SIGASP_APPROACH_2 )
					{
					state = SIGASP_APPROACH_2;
					}
				else
				{
					if ( next_state ==# SIGASP_APPROACH_3 )
						{
						state = SIGASP_APPROACH_3;
						}
					else
					{
						if ( next_state ==# SIGASP_CLEAR_1 )
							{
							state = SIGASP_CLEAR_1;
							}

						else
							{
							state = SIGASP_CLEAR_2;
							}
					}
				}
			}
		}
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////
// Signal Type Logic Scripts
// 
// Swedish Signals beta 3
// 2001 Mats Strid
//  emges@telia.com
//  http://msts.e-buzz.net
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
SCRIPT PriWarn5Light
////////////////////////////////////
// Infart / Forsignal, 5 lampor
////////////////////////////////////

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (!route_set()) //Vaxeln ligger fel, "kor 40"
	{
		state = SIGASP_APPROACH_1;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP) //Nasta stopp, visa "Kor vanta stopp"
			{
			state = SIGASP_APPROACH_2;
			}
		else if (next_state ==# SIGASP_RESTRICTING) //Nasta 40 avkortad, visa "Kor vanta 40"
			{
			state = SIGASP_APPROACH_3;
			}
		else if (next_state ==# SIGASP_APPROACH_1) //Nasta 40, visa "Kor vanta 40"
			{
			state = SIGASP_APPROACH_3;
			}
		else if (next_state ==# SIGASP_APPROACH_2 ||
		         next_state ==# SIGASP_APPROACH_3 
		) //Nasta Forsignal+Kor, visa "Kor vanta kor"
			{
			state = SIGASP_CLEAR_1;
			}
		else //Nasta kor, visa "Kor vanta kor"
		{
			state = SIGASP_CLEAR_1;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT PriWarn5SLight
////////////////////////////////////
// Infart / Forsignal, kort vag, 5 lampor
////////////////////////////////////

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (!route_set()) //Vaxeln ligger fel, "kor 40"
	{
		state = SIGASP_APPROACH_1;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP) //Nasta stopp, visa "Kor 40 avkortad"
			{
			state = SIGASP_RESTRICTING;
			}
		else if (next_state ==# SIGASP_RESTRICTING) //Nasta 40 avkortad, visa "Kor vanta 40"
			{
			state = SIGASP_APPROACH_3;
			}
		else if (next_state ==# SIGASP_APPROACH_1) //Nasta 40, visa "Kor vanta 40"
			{
			state = SIGASP_APPROACH_3;
			}
		else if (next_state ==# SIGASP_APPROACH_2 ||
		         next_state ==# SIGASP_APPROACH_3 
		) //Nasta Forsignal+Kor, visa "Kor vanta kor"
			{
			state = SIGASP_CLEAR_1;
			}
		else //Nasta kor, visa "Kor vanta kor"
		{
			state = SIGASP_CLEAR_1;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT PriWarn4Light
////////////////////////////////////
// Infart / Forsignal, 4 lampor
////////////////////////////////////


	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (!route_set()) //Vaxeln ligger fel, "kor 40"
	{
		state = SIGASP_APPROACH_1;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP) //Nasta stopp, visa "Kor vanta stopp"
			{
			state = SIGASP_APPROACH_2;
			}
		else if (next_state ==# SIGASP_APPROACH_2 ||
		         next_state ==# SIGASP_APPROACH_3 
		) //Nasta Forsignal+Kor, visa "Kor vanta kor"
			{
			state = SIGASP_CLEAR_1;
			}
		else //Nasta kor, visa "Kor vanta kor"
		{
			state = SIGASP_CLEAR_1;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Pri3Light
////////////////////////////////////
// Infartssignal, 3 lampor
////////////////////////////////////


	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (!route_set()) //Vaxeln ligger fel, "kor 40"
	{
		state = SIGASP_APPROACH_1;
	}

	else
	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Block2Light
////////////////////////////////////
// Blocksignal, 2 lampor
////////////////////////////////////


	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	
	else
	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Block5Light
////////////////////////////////////
// Block / Forsignal, 5 lampor
////////////////////////////////////

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP) //Nasta stopp, visa "Kor vanta stopp"
			{
			state = SIGASP_APPROACH_2;
			}
		else if (next_state ==# SIGASP_RESTRICTING) //Nasta 40 avkortad, visa "Kor vanta 40"
			{
			state = SIGASP_APPROACH_3;
			}
		else if (next_state ==# SIGASP_APPROACH_1) //Nasta 40, visa "Kor vanta 40"
			{
			state = SIGASP_APPROACH_3;
			}
		else if (next_state ==# SIGASP_APPROACH_2 ||
		         next_state ==# SIGASP_APPROACH_3 
		) //Nasta Forsignal+Kor, visa "Kor vanta kor"
			{
			state = SIGASP_CLEAR_1;
			}
		else //Nasta kor, visa "Kor vanta kor"
		{
			state = SIGASP_CLEAR_1;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Block5SLight
////////////////////////////////////
// Block / Forsignal, 5 lampor, kort vag
////////////////////////////////////

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP) //Nasta stopp, visa "Kor 40 avkortad"
			{
			state = SIGASP_RESTRICTING;
			}
		else if (next_state ==# SIGASP_RESTRICTING) //Nasta 40 avkortad, visa "Kor vanta 40"
			{
			state = SIGASP_APPROACH_3;
			}
		else if (next_state ==# SIGASP_APPROACH_1) //Nasta 40, visa "Kor vanta 40"
			{
			state = SIGASP_APPROACH_3;
			}
		else if (next_state ==# SIGASP_APPROACH_2 ||
		         next_state ==# SIGASP_APPROACH_3 
		) //Nasta Forsignal+Kor, visa "Kor vanta kor"
			{
			state = SIGASP_CLEAR_1;
			}
		else //Nasta kor, visa "Kor vanta kor"
		{
			state = SIGASP_CLEAR_1;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Block4Light
////////////////////////////////////
// Block / Forsignal, 4 lampor
////////////////////////////////////


	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP) //Nasta stopp, visa "Kor vanta stopp"
			{
			state = SIGASP_APPROACH_2;
			}
		else if (next_state ==# SIGASP_APPROACH_2 ||
		         next_state ==# SIGASP_APPROACH_3 
		) //Nasta Forsignal+Kor, visa "Kor vanta kor"
			{
			state = SIGASP_CLEAR_1;
			}
		else //Nasta kor, visa "Kor vanta kor"
		{
			state = SIGASP_CLEAR_1;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Middle2Light
////////////////////////////////////
// Mellansignal, 2 lampor
////////////////////////////////////


	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||	// Block ahead not clear?
		next_state ==# SIGASP_STOP )		// Next block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	
	else //Nasta kor, visa "Kor"
	{
		state = SIGASP_CLEAR_2; 
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Middle3Light
////////////////////////////////////
// Mellansignal, 3 lampor
////////////////////////////////////


	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.

	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||	// Block ahead not clear?
		next_state ==# SIGASP_STOP )		// Next block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	
	else //Nasta kor, visa "Kor 40"
	{
		state = SIGASP_APPROACH_1; 
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Warn3Light
////////////////////////////////////
// Forsignal, 3 lampor
////////////////////////////////////


	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP) //Nasta stopp, visa "Kor vanta stopp"
		{
			state = SIGASP_APPROACH_2;
		}
		else if (next_state ==# SIGASP_APPROACH_1 ||
		         next_state ==# SIGASP_RESTRICTING) //Nasta 40 (avkortad), visa "Kor vanta 40"
		{
			state = SIGASP_APPROACH_3;
		}
		else if (next_state ==# SIGASP_CLEAR_1) //Nasta kor, visa "Kor vanta kor"
		{
			state = SIGASP_CLEAR_1;
		}

		else //Nasta kor, visa "Kor vanta kor"
		{
			state = SIGASP_CLEAR_1;
		}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Cross1Light
////////////////////////////////////
// V-signal, 3 lampor
////////////////////////////////////


	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	state = SIGASP_CLEAR_2;

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT WarnCross3Light
////////////////////////////////////
// V-forsignal, 3 lampor
////////////////////////////////////


	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;


	state = SIGASP_CLEAR_2;

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT PriDwarf7Light
////////////////////////////////////
// Huvuddvargsignal, 7 lampor
////////////////////////////////////


	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_APPROACH_1 ||
		    next_state ==# SIGASP_RESTRICTING) //Nasta stopp eller 40 (kort), visa "Kor vanta 40stopp"
			{
			state = SIGASP_APPROACH_2;
			}
		else //Nasta kor, visa "Kor"
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT Dwarf4Light
////////////////////////////////////
// Dvargsignal, 4 lampor
////////////////////////////////////


	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;


// If required, show the appropriate 'stop' indication.
	if (!enabled ||					// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP) //Nasta stopp, visa "Rrelse hinder"
			{
			state = SIGASP_APPROACH_2;
			}
		else //Nasta kor, visa "Kor"
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////
// Signal Type Logic Scripts
///////////////////////////////////////////////////////////////////////////////

SCRIPT Test
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_mr ( SIGFN_DISTANCE );
	debug_header ();
	debug_out ( next_state );
	return;

SCRIPT Main
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_norm;

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( sig_feature ( SIGFEAT_USER4 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

		if ( next_state_norm < 3 || next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( sig_feature ( SIGFEAT_USER2 ) || enabled )
	{
		if ( block_state() ==# BLOCK_CLEAR )
		{
			state = 1;
			draw_state = def_draw_state ( state );
			return;
		}
		else
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	else
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}

	return;

SCRIPT Main_3
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	this_state_shunt;
	float	this_state_norm;
	float	next_state_dist;
	float	next_state_norm;
	float	next_state_shunt;


	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = 1; //this_sig_lr ( SIGFN_NORMAL );
	next_state_dist = next_sig_mr ( SIGFN_DISTANCE );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( sig_feature ( SIGFEAT_USER4 ) && ! ( this_state_shunt ==# 3 && next_state_shunt ==# 1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );

		if ( next_state_norm ==# 0 || next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( !( sig_feature ( SIGFEAT_USER2 ) || enabled ) )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}

	if ( this_state_shunt !=# 3 || this_state_norm ==# 0 || block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	if ( next_state_norm ==# 3 || next_state_norm ==# 4 || next_state_shunt ==# 1 )
	{
		state = 2;
		draw_state = def_draw_state ( state );
		return;
	}	
	if ( next_state_norm ==# 5 && next_state_shunt ==# 2 )
	{
		state = 2;
		draw_state = def_draw_state ( state );
		return;
	}	


	if ( next_state_dist ==# 0 )
	{
		state = 5;
		draw_state = def_draw_state ( state );
		return;
	}	
	state = 0;
	draw_state = def_draw_state ( state );
	return;

SCRIPT Main_3HL
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	this_state_shunt;
	float	this_state_norm;
	float	next_state_dist;
	float	next_state_norm;
	float	next_state_shunt;


	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = 1; //this_sig_lr ( SIGFN_NORMAL );
	next_state_dist = next_sig_mr ( SIGFN_DISTANCE );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( sig_feature ( SIGFEAT_USER4 ) && ! ( this_state_shunt ==# 3 && next_state_shunt ==# 1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );

		if ( next_state_norm ==# 0 || next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( !( sig_feature ( SIGFEAT_USER2 ) || enabled ) )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}

	if ( this_state_shunt !=# 3 || this_state_norm ==# 0 || block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	if ( next_state_norm ==# 3 || next_state_norm ==# 4 || next_state_shunt ==# 1 )
	{
		state = 2;
		draw_state = def_draw_state ( state );
		return;
	}	
	if ( next_state_norm ==# 5 && next_state_shunt ==# 2 )
	{
		state = 2;
		draw_state = def_draw_state ( state );
		return;
	}	


	if ( next_state_dist ==# 0 )
	{
		state = 5;
		draw_state = def_draw_state ( state );
		return;
	}	
	state = 0;
	draw_state = def_draw_state ( state );
	return;

SCRIPT Main_3Shx
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	this_state_shunt;
	float	this_state_norm;
	float	next_state_dist;
	float	next_state_norm;
	float	next_state_shunt;


	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = 1; //this_sig_lr ( SIGFN_NORMAL );
	next_state_dist = next_sig_mr ( SIGFN_DISTANCE );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( sig_feature ( SIGFEAT_USER4 ) && ! ( this_state_shunt ==# 3 && next_state_shunt ==# 1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );

		if ( next_state_norm ==# 0 || next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( !( sig_feature ( SIGFEAT_USER2 ) || enabled ) )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	if ( ( this_state_shunt !=# 1 && this_state_shunt !=# 3 && ! ( sig_feature ( SIGFEAT_USER4 ) ) ) || this_state_norm ==# 0 || block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	if ( this_state_shunt ==# 1 )
	{
		state = 3;
		draw_state = def_draw_state ( state );
		return;
	}	
	if ( next_state_norm ==# 3 || next_state_norm ==# 4 || next_state_shunt ==# 1  )
	{
		state = 2;
		draw_state = def_draw_state ( state );
		return;
	}	
	if ( next_state_norm ==# 5 && next_state_shunt ==# 2 )
	{
		state = 2;
		draw_state = def_draw_state ( state );
		return;
	}	
	if ( next_state_norm ==# 2 && next_state_shunt ==# 3 && sig_feature ( SIGFEAT_USER4 ) )
	{
		state = 2;
		draw_state = def_draw_state ( state );
		return;
	}	
	if ( next_state_dist ==# 0 )
	{
		state = 5;
		draw_state = def_draw_state ( state );
		return;
	}	
	state = 0;
	draw_state = def_draw_state ( state );
	return;

SCRIPT Main_4
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	this_state_shunt;
	float	this_state_norm;
	float	next_state_dist;
	float	next_state_norm;
	float	next_state_shunt;


	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = 1; //this_sig_lr ( SIGFN_NORMAL );
	next_state_dist = next_sig_mr ( SIGFN_DISTANCE );

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( sig_feature ( SIGFEAT_USER4 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

		if ( next_state_norm < 3 || next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( !( sig_feature ( SIGFEAT_USER2 ) || enabled ) )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}

	if ( this_state_shunt !=# 4 || this_state_norm ==# 0 || block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	if ( next_state_dist ==# 1 )
	{
		state = 3;
		draw_state = def_draw_state ( state );
		return;
	}	
	if ( next_state_dist ==# 2 )
	{
		state = 4;
		draw_state = def_draw_state ( state );
		return;
	}	
	if ( next_state_dist ==# 3 )
	{
		state = 5;
		draw_state = def_draw_state ( state );
		return;
	}	
	if ( next_state_dist ==# 4 )
	{
		state = 6;
		draw_state = def_draw_state ( state );
		return;
	}	
	if ( next_state_dist ==# 5 )
	{
		state = 7;
		draw_state = def_draw_state ( state );
		return;
	}	
	state = 0;
	draw_state = def_draw_state ( state );
	return;

SCRIPT Main_5
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	this_state_shunt;
	float	this_state_norm;
	float	next_state_dist;
	float	next_state_norm;
	float	next_state_shunt;


	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = 1; //this_sig_lr ( SIGFN_NORMAL );
	next_state_dist = next_sig_mr ( SIGFN_DISTANCE );

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( sig_feature ( SIGFEAT_USER4 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

		if ( next_state_norm < 3 || next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( !( sig_feature ( SIGFEAT_USER2 ) || enabled ) )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}

	if ( this_state_shunt !=# 5 || this_state_norm ==# 0 || block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	if ( next_state_dist ==# 6 )
	{
		state = 7;
		draw_state = def_draw_state ( state );
		return;
	}	
	state = 0;
	draw_state = def_draw_state ( state );
	return;

SCRIPT Main_7
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	this_state_shunt;
	float	this_state_norm;
	float	next_state_dist;
	float	next_state_norm;
	float	next_state_shunt;


	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = 1; //this_sig_lr ( SIGFN_NORMAL );
	next_state_dist = next_sig_mr ( SIGFN_DISTANCE );

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( sig_feature ( SIGFEAT_USER4 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

		if ( next_state_norm < 3 || next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( !( sig_feature ( SIGFEAT_USER2 ) || enabled ) )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}

	if ( this_state_shunt !=# 7 || this_state_norm ==# 0 || block_state() !=# BLOCK_CLEAR )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	if ( next_state_dist ==# 7 )
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( sig_feature ( SIGFEAT_NUMBER_PLATE ) && ( next_state_norm < 6 || next_state_shunt < 7 ) )
		{
			state = 6;
			draw_state = def_draw_state ( state );
			return;
		}
		else
		{
			state = 7;
			draw_state = def_draw_state ( state );
			return;
		}
	}	
	state = 0;
	draw_state = def_draw_state ( state );
	return;

SCRIPT ROT01
	extern float	this_sig_lr ();
	extern float	draw_state;

	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm < 3 )
	{
		draw_state = 0;
	}
	else
	{
		draw_state = 1;
	}
	return;

SCRIPT ROT02
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();

	extern float	draw_state;

	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;
	float	next_state_shunt;
	float	next_state_norm;


	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	this_state_norm = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm ==# 2 && ( next_state_shunt ==# 1 || next_state_shunt ==# 2 ) )
	{
		draw_state = 1;
	}
	else if ( this_state_norm < 3 )
	{
		draw_state = 0;
	}
	else
	{
		draw_state = 1;
	}
	return;

SCRIPT ROT01Fo
	extern float	this_sig_lr ();
	extern float	draw_state;

	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm < 3 )
	{
		draw_state = 0;
	}
	else
	{
		draw_state = 1;
	}
	return;

SCRIPT GRUEN01
	extern float	this_sig_lr ();
	extern float	draw_state;

	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm > 2 )
	{
		draw_state = 1;
	}
	else
	{
		draw_state = 0;
	}
	return;

SCRIPT GELB01
	extern float	this_sig_lr ();
	extern float	draw_state;

	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm > 2 && this_state_norm < 6 )
	{
		draw_state = 1;
	}
	else
	{
		draw_state = 0;
	}
	return;

SCRIPT GELB01Fo
	extern float	this_sig_lr ();
	extern float	draw_state;

	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm > 2 && this_state_norm < 6 )
	{
		draw_state = 1;
	}
	else
	{
		draw_state = 0;
	}
	return;


SCRIPT WeissRa01
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	this_state_norm;
	float	next_state_norm;
	
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm !=# 4 )
	{
		draw_state = 1;
		return;
	}

	draw_state = 0;
	return;	

SCRIPT WeissEr01
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	this_state_norm;
	float	next_state_norm;
	
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm ==# 4 )
	{
		draw_state = 1;
		return;
	}
	if ( this_state_norm ==# 2 && next_state_shunt ==# 2 && next_state_norm ==# 5 )
	{
		draw_state = 2;
		return;
	}


	draw_state = 0;
	return;	

SCRIPT WeissEr02
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	this_state_norm;
	float	next_state_norm;
	
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm ==# 4 )
	{
		draw_state = 1;
		return;
	}
	if ( this_state_norm ==# 2 && next_state_shunt ==# 2 && next_state_norm ==# 5 )
	{
		draw_state = 2;
		return;
	}
	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm ==# 3 )
	{
		draw_state = 3;
		return;
	}



	draw_state = 0;
	return;	

SCRIPT WeissHPDB01
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	this_state_norm;
	float	next_state_norm;
	
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm ==# 4 )
	{
		draw_state = 1;
		return;
	}
	if ( this_state_norm ==# 2 && next_state_shunt ==# 2 && next_state_norm ==# 5 )
	{
		draw_state = 2;
		return;
	}
	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm !=# 4 )
	{
		draw_state = 3;
		return;
	}


	draw_state = 0;
	return;	

SCRIPT WeissHPDR01
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	this_state_norm;
	float	next_state_norm;
	
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm ==# 4 )
	{
		draw_state = 1;
		return;
	}
	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm !=# 4 )
	{
		draw_state = 2;
		return;
	}


	draw_state = 0;
	return;	


SCRIPT WeissVo01
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	this_state_norm;
	float	next_state_norm;
	
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm !=# 4 )
	{
		draw_state = 1;
		return;
	}
	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm ==# 4 )
	{
		draw_state = 1;
		return;
	}
	if ( this_state_norm ==# 2 && next_state_shunt ==# 2 && next_state_norm ==# 5 )
	{
		draw_state = 1;
		return;
	}


	draw_state = 0;
	return;	

SCRIPT WeissVo01KS
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	this_state_norm;
	float	next_state_norm;
	
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm !=# 4 )
	{
		draw_state = 0;
		return;
	}
	if ( this_state_norm ==# 2 && next_state_shunt ==# 1 && next_state_norm ==# 4 )
	{
		draw_state = 1;
		return;
	}
	if ( this_state_norm ==# 2 && next_state_shunt ==# 2 && next_state_norm ==# 5 )
	{
		draw_state = 1;
		return;
	}


	draw_state = 0;
	return;	

SCRIPT GELB01VR
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 1;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 5 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT GELB01VRKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 1;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 2 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT GELB01VRKSHP
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );
	this_state_hp = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
//		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
//		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || this_state_hp < 3 )
	{
		draw_state = 1;
		return;
	}
	else
	{
		if ( next_state_norm > 2 )
		{
			draw_state = 0;
			return;
		}
		else
		{
			draw_state = 1;
			return;
		}
	}

	return;

SCRIPT GELB02VR
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 1;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 2 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT GRUEN01VR
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 5 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT GRUEN01VRKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 5 && next_state_shunt > 6 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 2;
			return;
		}
	}

	return;

SCRIPT GRUEN01VRKSHP
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_hp;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );
	this_state_hp = this_sig_lr ( SIGFN_NORMAL );
	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );

	if ( this_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
//		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
//		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || this_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( ( next_state_norm > 5 && next_state_shunt > 6 ) || ( next_state_norm >= this_state_hp && next_state_shunt >= this_state_shunt ) )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 2;
			return;
		}
	}

	return;

SCRIPT GRUEN02VR
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 2 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT WEISS01VR
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();
	extern float	route_set ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( route_set() )
	{
		draw_state = 1;
		return;
	}
	else
	{
		draw_state = 0;
		return;
	}
	return;

SCRIPT WEISS01VRKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();
	extern float	route_set ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 1;
		return;
	}

	if ( route_set() )
	{
		if ( next_state_norm > 5 && next_state_shunt > 6 )
		{
			draw_state = 0;
			return;
		}
		else
		{
			draw_state = 1;
			return;
		}
	}
	else
	{
		draw_state = 0;
		return;
	}
	return;

SCRIPT WEISS01VRKSHP
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();
	extern float	route_set ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_hp;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );
	this_state_hp = this_sig_lr ( SIGFN_NORMAL );
	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );

	if ( this_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
//		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
//		next_state_shunt = next_sig_lr ( SIGFN_INFO );

		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( route_set() )
	{
		if ( ( next_state_norm > 5 && next_state_shunt > 6 ) || ( next_state_norm >= this_state_hp && next_state_shunt >= this_state_shunt ) )
		{
			draw_state = 0;
			return;
		}
		else
		{
			draw_state = 1;
			return;
		}
	}
	else
	{
		draw_state = 0;
		return;
	}
	return;

SCRIPT WEISS02VRKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();
	extern float	route_set ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 1;
		return;
	}

	if ( next_state_norm > 5 && next_state_shunt > 6 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		draw_state = 1;
		return;
	}
	return;

SCRIPT VRHPFl1DB
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 5 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT VRHPFl1DBL
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 2 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT VRHPFl2DB
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3  )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 2 && next_state_norm < 6 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT VRHPFl2DBL
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3  )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 5 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT VRHPFl1DR
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3  )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 5 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT VRHPFl2DR
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3  )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm > 2 && next_state_norm < 6 )
		{
			draw_state = 1;
			return;
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;


SCRIPT ShxHead
	extern float	this_sig_lr ();
	extern float	draw_state;

	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm > 0 )
	{
		draw_state = 1;
	}
	else
	{
		draw_state = 0;
	}
	return;

SCRIPT LSPHead
	extern float	this_sig_lr ();
	extern float	draw_state;

	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );

	if ( this_state_norm > 0 )
	{
		draw_state = 1;
	}
	else
	{
		draw_state = 0;
	}
	return;

SCRIPT ZS3_03
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_norm;
	float	this_state_shunt;
	float	this_state_norm;

	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( next_state_shunt ==# 3 && next_state_norm ==# 5 )
	{
		draw_state = 1;
		return;
	}
	else
	{
		draw_state = 0;
		return;
	}
	return;

SCRIPT ZS3_04
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_norm;
	float	this_state_shunt;
	float	this_state_norm;

	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( next_state_shunt ==# 4 && next_state_norm ==# 3 )
	{
		draw_state = 1;
		return;
	}
	else
	{
		draw_state = 0;
		return;
	}
	return;

SCRIPT ZS3_05
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_norm;
	float	this_state_shunt;
	float	this_state_norm;

	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( next_state_shunt ==# 4 && next_state_norm ==# 4 )
	{
		draw_state = 1;
		return;
	}
	else
	{
		draw_state = 0;
		return;
	}
	return;

SCRIPT ZS3_06
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_norm;
	float	this_state_shunt;
	float	this_state_norm;

	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( next_state_shunt ==# 4 && next_state_norm ==# 5 )
	{
		draw_state = 1;
		return;
	}
	else
	{
		draw_state = 0;
		return;
	}
	return;

SCRIPT ZS3_07
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_norm;
	float	this_state_shunt;
	float	this_state_norm;

	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( next_state_shunt ==# 4 && next_state_norm ==# 6 )
	{
		draw_state = 1;
		return;
	}
	else
	{
		draw_state = 0;
		return;
	}
	return;

SCRIPT ZS3_08
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_norm;
	float	this_state_shunt;
	float	this_state_norm;

	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( next_state_shunt ==# 4 && next_state_norm ==# 7 )
	{
		draw_state = 1;
		return;
	}
	else
	{
		draw_state = 0;
		return;
	}
	return;

SCRIPT ZS3_10
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_norm;
	float	this_state_shunt;
	float	this_state_norm;

	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( next_state_shunt ==# 5 && next_state_norm ==# 7 )
	{
		draw_state = 1;
		return;
	}
	else
	{
		draw_state = 0;
		return;
	}
	return;

SCRIPT ZS3_03v
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 5 && next_state_shunt ==# 3 )
		{
			if ( ( this_state_norm > 5 && this_state_shunt ==# 3 ) || this_state_shunt > 3 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_04v
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 3 && next_state_shunt ==# 4 )
		{
			if ( ( this_state_norm > 3 && this_state_shunt ==# 4 ) || this_state_shunt > 4 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_05v
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 4 && next_state_shunt ==# 4 )
		{
			if ( ( this_state_norm > 4 && this_state_shunt ==# 4 ) || this_state_shunt > 4 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_06v
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 5 && next_state_shunt ==# 4 )
		{
			if ( ( this_state_norm > 5 && this_state_shunt ==# 4 ) || this_state_shunt > 4 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_07v
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 6 && next_state_shunt ==# 4 )
		{
			if ( ( this_state_norm > 6 && this_state_shunt ==# 4 ) || this_state_shunt > 4 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_08v
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 7 && next_state_shunt ==# 4 )
		{
			if ( ( this_state_norm > 7 && this_state_shunt ==# 4 ) || this_state_shunt > 4 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_10v
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 7 && next_state_shunt ==# 5 )
		{
			if ( ( this_state_norm > 7 && this_state_shunt ==# 5 ) || this_state_shunt > 5 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_03vKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 5 && next_state_shunt ==# 3 )
		{
			if ( ( this_state_norm > 5 && this_state_shunt ==# 3 ) || this_state_shunt > 3 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_04vKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 3 && next_state_shunt ==# 4 )
		{
			if ( ( this_state_norm > 3 && this_state_shunt ==# 4 ) || this_state_shunt > 4 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_05vKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 4 && next_state_shunt ==# 4 )
		{
			if ( ( this_state_norm > 4 && this_state_shunt ==# 4 ) || this_state_shunt > 4 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_06vKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 5 && next_state_shunt ==# 4 )
		{
			if ( ( this_state_norm > 5 && this_state_shunt ==# 4 ) || this_state_shunt > 4 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_07vKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 6 && next_state_shunt ==# 4 )
		{
			if ( ( this_state_norm > 6 && this_state_shunt ==# 4 ) || this_state_shunt > 4 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_08vKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 7 && next_state_shunt ==# 4 )
		{
			if ( ( this_state_norm > 7 && this_state_shunt ==# 4 ) || this_state_shunt > 4 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT ZS3_10vKS
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;
	float	this_state_norm;
	float	this_state_shunt;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER3 ) && next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		this_state_norm = next_sig_lr ( SIGFN_NORMAL );
		this_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}
	else
	{
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		this_state_norm = 7;
		this_state_shunt = 7;
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		if ( next_state_norm ==# 7 && next_state_shunt ==# 5 )
		{
			if ( ( this_state_norm > 7 && this_state_shunt ==# 5 ) || this_state_shunt > 5 )
			{
				draw_state = 1;
				return;
			}
			else
			{
				draw_state = 0;
				return;
			}
		}
		else
		{
			draw_state = 0;
			return;
		}
	}

	return;

SCRIPT 1Gleis
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_norm;
	float	this_state_shunt;
	float	this_state_norm;

	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING ); 
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

	if ( this_state_shunt ==# 0 )
	{
		state = 2;
		draw_state = def_draw_state ( state );
		return;
	}

	if ( this_state_shunt ==# 1 )
	{
	 	if ( sig_feature ( SIGFEAT_USER3 ) )
		{
			next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
			if ( next_state_shunt ==# 0 )
			{
				state = 0;
				draw_state = def_draw_state ( state );
				return;
			}
		}
		if ( sig_feature ( SIGFEAT_USER4 ) )
		{
			next_state_norm = next_sig_lr ( SIGFN_NORMAL );
			next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

			if ( next_state_norm ==# 0 || next_state_shunt ==# 0 )
			{
				state = 0;
				draw_state = def_draw_state ( state );
				return;
			}
		}
		if ( sig_feature ( SIGFEAT_USER2 ) || enabled )
		{
			if ( block_state() ==# BLOCK_CLEAR )
			{
				if ( sig_feature ( SIGFEAT_GRADIENT_PLATE ) )
				{
					state = 4;
					draw_state = def_draw_state ( state );
					return;
				}
				else
				{
					state = 3;
					draw_state = def_draw_state ( state );
					return;
				}
			}
			else
			{
				state = 0;
				draw_state = def_draw_state ( state );
				return;
			}
		}
		else
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}

	if ( this_state_shunt ==# 2 )
	{
	 	if ( sig_feature ( SIGFEAT_USER3 ) )
		{
			next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
			if ( next_state_shunt ==# 0 )
			{
				state = 2;
				draw_state = def_draw_state ( state );
				return;
			}
		}
		if ( sig_feature ( SIGFEAT_USER4 ) )
		{
			next_state_norm = next_sig_lr ( SIGFN_NORMAL );
			next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

			if ( next_state_norm ==# 0 || next_state_shunt ==# 0 )
			{
				state = 2;
				draw_state = def_draw_state ( state );
				return;
			}
		}
		if ( sig_feature ( SIGFEAT_USER2 ) || enabled )
		{
			if ( block_state() ==# BLOCK_CLEAR )
			{
				state = 5;
				draw_state = def_draw_state ( state );
				return;
			}
			else
			{
				state = 2;
				draw_state = def_draw_state ( state );
				return;
			}
		}
		else
		{
			state = 2;
			draw_state = def_draw_state ( state );
			return;
		}
	}

	if ( this_state_shunt ==# 7 )
	{
	 	if ( sig_feature ( SIGFEAT_USER3 ) )
		{
			next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
			if ( next_state_shunt ==# 0 )
			{
				state = 2;
				draw_state = def_draw_state ( state );
				return;
			}
		}
		if ( sig_feature ( SIGFEAT_USER4 ) )
		{
			next_state_norm = next_sig_lr ( SIGFN_NORMAL );
			next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

			if ( next_state_norm ==# 0 || next_state_shunt ==# 0 )
			{
				state = 2;
				draw_state = def_draw_state ( state );
				return;
			}
		}
		if ( sig_feature ( SIGFEAT_USER2 ) || enabled )
		{
			if ( block_state() ==# BLOCK_CLEAR )
			{
				state = 7;
				draw_state = def_draw_state ( state );
				return;
			}
			else
			{
				state = 2;
				draw_state = def_draw_state ( state );
				return;
			}
		}
		else
		{
			state = 2;
			draw_state = def_draw_state ( state );
			return;
		}
	}

	return;

SCRIPT Gleisende
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_norm;
	float	this_state_shunt;
	float	this_state_norm;

	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING ); 
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	
	if ( this_state_shunt ==# 1 )
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	state = 1;
	draw_state = def_draw_state ( state );
	return;



SCRIPT SigTyp
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_dist;

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}

	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

	if ( next_state_shunt ==# 1 || next_state_shunt ==# 2 )
	{
		state = 3;
		draw_state = def_draw_state ( state );
		return;
	}

	if ( block_state() ==# BLOCK_CLEAR )
	{
		next_state_dist = next_sig_lr ( SIGFN_DISTANCE );
		if ( next_state_dist ==# 0 )
		{
			state = 3;
			draw_state = def_draw_state ( state );
			return;
		}
		else if ( next_state_dist > 0 && next_state_dist < 6 )
		{
			state = 4;
			draw_state = def_draw_state ( state );
			return;
		}
		else if ( next_state_dist ==# 6 )
		{
			state = 5;
			draw_state = def_draw_state ( state );
			return;
		}
		else if ( next_state_dist ==# 7 )
		{
			state = 7;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	else
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	return;

SCRIPT SigTypShx
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_dist;
	float	next_state_norm;

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}

	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );

	if ( next_state_shunt ==# 1 || next_state_shunt ==# 2 )
	{
		state = 3;
		draw_state = def_draw_state ( state );
		return;
	}

	if ( sig_feature ( SIGFEAT_USER4 ) && next_state_shunt ==# 3 && next_state_norm ==# 2 )
	{
		state = 3;
		draw_state = def_draw_state ( state );
		return;
	}

	if ( block_state() ==# BLOCK_CLEAR )
	{
		next_state_dist = next_sig_lr ( SIGFN_DISTANCE );
		if ( next_state_dist ==# 0 )
		{
			state = 3;
			draw_state = def_draw_state ( state );
			return;
		}
		else if ( next_state_dist > 0 && next_state_dist < 6 )
		{
			state = 4;
			draw_state = def_draw_state ( state );
			return;
		}
		else if ( next_state_dist ==# 6 )
		{
			state = 5;
			draw_state = def_draw_state ( state );
			return;
		}
		else if ( next_state_dist ==# 7 )
		{
			state = 7;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	else
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	return;

SCRIPT Wechsel
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_dist;

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( block_state() ==# BLOCK_CLEAR )
	{
		state = 7;
		draw_state = def_draw_state ( state );
		return;
	}
	else
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	return;

SCRIPT Falsch
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_shunt;
	float	next_state_dist;

	if ( sig_feature ( SIGFEAT_USER3 ) )
	{
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
		if ( next_state_shunt ==# 0 )
		{
			state = 0;
			draw_state = def_draw_state ( state );
			return;
		}
	}
	if ( block_state() ==# BLOCK_CLEAR )
	{
		state = 2;
		draw_state = def_draw_state ( state );
		return;
	}
	else
	{
		state = 0;
		draw_state = def_draw_state ( state );
		return;
	}
	return;

SCRIPT Durch_Dist
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_lr ( SIGFN_DISTANCE );
	state = next_state ;
	draw_state = def_draw_state ( state );

	return;

SCRIPT Durch_Shunt
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_lr ( SIGFN_SHUNTING );
	state = next_state ;
	draw_state = def_draw_state ( state );

	return;

SCRIPT Durch_Info
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_lr ( SIGFN_INFO );
	state = next_state ;
	draw_state = def_draw_state ( state );

	return;

SCRIPT Umsetz_Info
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = this_sig_lr ( SIGFN_SHUNTING );
	state = next_state ;
	draw_state = def_draw_state ( state );

	return;

SCRIPT Umsetz_Info_Next
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_lr ( SIGFN_SHUNTING );
	state = next_state ;
	draw_state = def_draw_state ( state );

	return;

SCRIPT Durch_Repea
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_lr ( SIGFN_REPEATER );
	state = next_state ;
	draw_state = def_draw_state ( state );

	return;

SCRIPT Umsetz_Repea
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = this_sig_lr ( SIGFN_NORMAL );
	state = next_state ;
	draw_state = def_draw_state ( state );

	return;

SCRIPT Umsetz_Repea_next
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_lr ( SIGFN_NORMAL );
	state = next_state ;
	draw_state = def_draw_state ( state );

	return;

SCRIPT PZB_30
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_mr ( SIGFN_DISTANCE );
	state = SIGASP_STOP;
	if (!( sig_feature ( SIGFEAT_USER1 )) && ( next_state < state ) && ( next_state >= 0 ))
	{
		state = next_state ;
	}

	draw_state = def_draw_state ( state );

	return;

SCRIPT PZB_40
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;

	next_state = next_sig_mr ( SIGFN_DISTANCE );
	state = SIGASP_STOP_AND_PROCEED;

	if (!( sig_feature ( SIGFEAT_USER1 )) && ( next_state < state ) && ( next_state >= 0 ))
	{
		state = next_state ;
	}
	draw_state = def_draw_state ( state );

	return;

SCRIPT PZB_50
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_mr ( SIGFN_DISTANCE );
	state = SIGASP_RESTRICTING;
	if (!( sig_feature ( SIGFEAT_USER1 )) && ( next_state < state ) && ( next_state >= 0 ))
	{
		state = next_state ;
	}

	draw_state = def_draw_state ( state );

	return;

SCRIPT PZB_60
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_mr ( SIGFN_DISTANCE );
	state = SIGASP_APPROACH_1;

	if (!( sig_feature ( SIGFEAT_USER1 )) && ( next_state < state ) && ( next_state >= 0 ))
	{
		state = next_state ;
	}

	draw_state = def_draw_state ( state );

	return;


SCRIPT PZB_70
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_mr ( SIGFN_DISTANCE );
	state = SIGASP_APPROACH_2;
	if (!( sig_feature ( SIGFEAT_USER1 )) && ( next_state < state ) && ( next_state >= 0 ))
	{
		state = next_state ;
	}

	draw_state = def_draw_state ( state );

	return;

SCRIPT PZB_80
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_mr ( SIGFN_DISTANCE );
	state = SIGASP_APPROACH_3;
	if (!( sig_feature ( SIGFEAT_USER1 )) && ( next_state < state ) && ( next_state >= 0 ))
	{
		state = next_state ;
	}

	draw_state = def_draw_state ( state );

	return;

SCRIPT PZB_100
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_mr ( SIGFN_DISTANCE );
	state = SIGASP_CLEAR_1;
	if (!( sig_feature ( SIGFEAT_USER1 )) && ( next_state < state ) && ( next_state >= 0 ))
	{
		state = next_state ;
	}

	draw_state = def_draw_state ( state );

	return;


SCRIPT PZB_MAX
	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	next_sig_lr ();
	extern float	next_sig_mr ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state;
	float	this_state;
	
	next_state = next_sig_mr ( SIGFN_DISTANCE );
	state = SIGASP_CLEAR_2;
	if (!( sig_feature ( SIGFEAT_USER1 )) && ( next_state < state ) && ( next_state >= 0 ))
	{
		state = next_state ;
	}

	draw_state = def_draw_state ( state );

	return;

SCRIPT GRUEN01HL
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();


	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;
	float	next_state_norm;
	float	next_state_shunt;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

	if ( this_state_norm > 2 )
	{
		if  ( sig_feature ( SIGFEAT_USER1 ) )
		{		
			draw_state = 1;
		}
		else if ( next_state_norm > 5 and next_state_shunt ==# 7 )
		{		
			draw_state = 1;
		}
		else
		{		
			draw_state = 0;
		}
	}
	else
	{
		draw_state = 0;
	}
	return;

SCRIPT GELB02HL
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();


	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;
	float	next_state_norm;
	float	next_state_shunt;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

	if ( this_state_norm > 2 )
	{
		if  ( sig_feature ( SIGFEAT_USER1 ) )
		{		
			draw_state = 0;
		}
		else if ( next_state_norm < 3 )
		{		
			draw_state = 1;
		}
		else
		{		
			draw_state = 0;
		}
	}
	else
	{
		draw_state = 0;
	}
	return;

SCRIPT GELB01HL
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();


	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;
	float	next_state_norm;
	float	this_state_shunt;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );

	if ( this_state_norm > 2 )
	{
		if  ( ( this_state_shunt < 7 ) )
		{		
			draw_state = 1;
		}
		else
		{		
			draw_state = 0;
		}
	}
	else
	{
		draw_state = 0;
	}
	return;

SCRIPT HL100
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();


	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;
	float	next_state_norm;
	float	this_state_shunt;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );

	if ( this_state_norm ==# 7 &&  this_state_shunt ==# 5  )
	{
		draw_state = 1;
	}
	else
	{
		draw_state = 0;
	}
	return;

SCRIPT HL060
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();


	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;
	float	next_state_norm;
	float	this_state_shunt;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );

	if ( this_state_norm ==# 5 &&  this_state_shunt ==# 4  )
	{
		draw_state = 1;
	}
	else
	{
		draw_state = 0;
	}
	return;

SCRIPT WeissHL
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();


	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;
	float	next_state_norm;
	float	next_state_shunt;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

	if ( this_state_norm ==# 2 &&  next_state_shunt ==# 1 && next_state_norm ==# 3 )
	{
		draw_state = 1;
	}
	else
	{
		draw_state = 0;
	}

	return;

SCRIPT HL_KURZ
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();
	extern float	route_set ();

	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;
	float	next_state_norm;
	float	this_state_shunt;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	this_state_shunt = this_sig_lr ( SIGFN_SHUNTING );

	if ( ( this_state_norm ==# 5 &&  this_state_shunt ==# 3 ) ||  ( route_set() && this_state_norm > 2 ) )
	{
		draw_state = 1;
	}
	else
	{
		draw_state = 0;
	}

	return;

SCRIPT Blink_HL
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();
	extern float	route_set ();

	extern float debug_header();
	extern float debug_out();

	float	this_state_norm;
	float	next_state_norm;
	float	next_state_shunt;

	this_state_norm = this_sig_lr ( SIGFN_NORMAL );
	next_state_norm = next_sig_lr ( SIGFN_NORMAL );
	next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );

	if ( this_state_norm > 2 &&  next_state_shunt < 5 && next_state_norm > 2 && !sig_feature ( SIGFEAT_USER1 ) )
	{
		draw_state = 2;
	}
	else if ( this_state_norm > 2 &&  next_state_shunt ==# 5 && next_state_norm > 2 && !sig_feature ( SIGFEAT_USER1 ) )
	{
		draw_state = 1;
	}
	else if ( this_state_norm ==# 2 &&  next_state_shunt ==# 1 && next_state_norm ==# 4 )
	{
		draw_state = 4;
	}
	else if ( this_state_norm ==# 2 &&  next_state_shunt ==# 2 )
	{
		draw_state = 3;
	}
	else
	{
		draw_state = 0;
	}

	return;

SCRIPT GELB02HLVo
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}
	else
	{
		draw_state = 1;
		return;
	}
	return;



SCRIPT GRUEN01HLVo
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}
	else if ( next_state_shunt > 5 && next_state_norm > 5 )
	{
		draw_state = 1;
		return;
	}
	return;

SCRIPT Blink_HLVo
	extern float	block_state ();
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	sig_feature ();

	extern float debug_header();
	extern float debug_out();

	float	next_state_norm;
	float	next_state_shunt;
	float	next_state_hp;

	next_state_hp = next_sig_lr ( SIGFN_NORMAL );

	if ( sig_feature ( SIGFEAT_USER1 ) )
	{
		next_state_norm = next_sig_lr ( SIGFN_REPEATER );
		next_state_shunt = next_sig_lr ( SIGFN_INFO );
	}
	else
	{
		next_state_norm = next_sig_lr ( SIGFN_NORMAL );
		next_state_shunt = next_sig_lr ( SIGFN_SHUNTING );
	}

	if ( block_state() !=# BLOCK_CLEAR && sig_feature ( SIGFEAT_USER2 ) )
	{
		draw_state = 0;
		return;
	}

	if ( next_state_shunt < 3 || next_state_norm < 3 || next_state_hp < 3 )
	{
		draw_state = 0;
		return;
	}
	else if ( next_state_shunt ==# 4 || next_state_shunt ==# 3 )
	{
		draw_state = 2;
		return;
	}
	else if ( next_state_shunt ==# 5 )
	{
		draw_state = 1;
		return;
	}
	return;

///////////////////////////////////////////////////////////////////////////////
// End of File
///////////////////////////////////////////////////////////////////////////////

