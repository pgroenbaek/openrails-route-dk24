//////////////////////////////////////////////////////////////////////////
//	Danish Signal configuration file 				//
//	This file may be redistributed 					//
//									//
//	Rel. 4.0   							//
//	Copyright:							//
//	Team RouteBuilders DK						//
//	Stig Christensen  27-06-2003					//
//////////////////////////////////////////////////////////////////////////



SCRIPT KBSemRoute
// dk TU armsignal

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!enabled || block_state() ==# BLOCK_JN_OBSTRUCTED )
	
	{
		state = SIGASP_STOP;
	}
	else if ( next_state ==# SIGASP_CLEAR_1 || next_state==# SIGASP_CLEAR_2 )							 
	{
		state = SIGASP_CLEAR_2;
	}
	else if (next_state ==# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	else 
	{
		state = SIGASP_STOP;
	}	

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT KBSemDist
//nyt Script som tager hoejde for foer / efter 1961

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	extern float	next_sig_lr ();
	float		next_state;
	float		Efter_61;

	Efter_61 = sig_feature (SIGFEAT_USER1);
	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( Efter_61 )
	{
//  Efter 1961
		if ( next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			state = SIGASP_APPROACH_2;
		}

	}
	else
	{
//  foer 1961
		if ( next_state ==# SIGASP_STOP ) 
		{
			state = SIGASP_APPROACH_2;
		}
		else
		{
			state = SIGASP_CLEAR_2;
		}
	}
// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT KBSemMain

// Kystbanen Semaphore Signal Main, main arm
	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}


// Get draw state
	draw_state = def_draw_state (state);
//////////////////////////////////////////////////////////////////////////////////////

SCRIPT KBSemEntryHead1

// Kystbanen Semaphore Signal Entry, main arm

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				state = SIGASP_CLEAR_1;
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);


//////////////////////////////////////////////////////////////////////////////////////
SCRIPT KBSemEntryHead2

// Kystbanen Semaphore Signal Entry, entry arm
// When down/yellow: slow speed
// When up/green:    go through

	extern float	this_sig_lr ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);
	state = SIGASP_STOP;
	if (this_state ==# SIGASP_CLEAR_2)

	{
	state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);
//////////////////////////////////////////////////////////////////////////////////////

SCRIPT dkam
// dkam signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		VD;


	VD = sig_feature (SIGFEAT_USER1);
	next_state = next_sig_lr (SIGFN_NORMAL);

	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( enabled ) 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 || next_state ==# SIGASP_APPROACH_3)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			state = SIGASP_CLEAR_1;
		}
	}
	else
	{
		if ( VD )	
		{
			state = SIGASP_STOP;
		}
		else 
		{
			state = SIGASP_RESTRICTING;
		}

	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dkamsbane
// dk am signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;



	next_state = next_sig_lr (SIGFN_NORMAL);

	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( !enabled ) 
	{
		state = SIGASP_RESTRICTING;
	}
	else 
	{
	if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 || next_state ==# SIGASP_APPROACH_3)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			state = SIGASP_CLEAR_1;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk2udsbane
// dk  ud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SU;


	SU = sig_feature (SIGFEAT_USER1);


// If required, show the 'stop' indication.
	if ( !route_set ()|| !enabled || block_state() !=# BLOCK_CLEAR )
	// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 ||
			next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			if ( SU )
			{
				state = SIGASP_APPROACH_3;
			}
			else
			{
				state = SIGASP_CLEAR_1;
			}
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dk2ud
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk3ud
// dk ud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SU;


	SU = sig_feature (SIGFEAT_USER1);



	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else 
	{
	if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
		else
		{
			if ( SU )
			{
				state = SIGASP_APPROACH_3;
			}
			else
			{
				state = SIGASP_CLEAR_1;
			}
		}
	}

// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4ind

// dkind signal head 4 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4ind_old

// dkind signal head 4 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT dk1distant

// Dk distant signal

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	state = SIGASP_APPROACH_2;

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dk2distant

// Dk distant signal

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);

	state = SIGASP_APPROACH_2;
	if (next_state ==# SIGASP_CLEAR_1 ||
		next_state ==# SIGASP_CLEAR_2) 
	{
		state = SIGASP_CLEAR_1;
	}
// Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////////
SCRIPT dk3distant

// Dk distant signal

	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		next_state;

	next_state = next_sig_lr (SIGFN_INFO);

	state = SIGASP_APPROACH_2;
	if (next_state ==# SIGASP_CLEAR_1) 
	{
		state = SIGASP_CLEAR_1;
	}

	else if (next_state ==# SIGASP_CLEAR_2) 

	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dktusig
// dk TU signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);

	if (!enabled || block_state() ==# BLOCK_JN_OBSTRUCTED )
	
	{
		state = SIGASP_STOP;
	}
	else if ( next_state ==# SIGASP_CLEAR_1 || next_state==# SIGASP_CLEAR_2 )							 
	{
		state = SIGASP_CLEAR_2;
	}
	else if (next_state ==# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	else 
	{
		state = SIGASP_STOP;
	}	

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkunsecskilt
// dk unsecure area follows

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

		state = SIGASP_APPROACH_1;


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkstopskilt
// dk STOP SIGN

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

		state = SIGASP_STOP;


// Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////////




SCRIPT dk-dvsig

// dk Dvaerg signal head

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		rangerspor;


	rangerspor = sig_feature (SIGFEAT_USER1);

// If required, show the 'stop' indication.

	if (!enabled ) 
	{
		if ( rangerspor ) 
		{		
			state = SIGASP_STOP_AND_PROCEED;
		}
		else	
		{
			state = SIGASP_STOP;
		}
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED ) 
	// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else 
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);
		state = SIGASP_RESTRICTING;

		if (next_state ==# SIGASP_APPROACH_1 || next_state ==# SIGASP_RESTRICTING ) 
		{
			state = SIGASP_APPROACH_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_2; 
		}
		else if(next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_APPROACH_3;
		}
		else if(next_state ==# SIGASP_CLEAR_1)
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk5indv

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT left_arm

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 
			state = SIGASP_APPROACH_3;
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT dk6indv

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Left_arm_g

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);



// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);




///////////////////////////////////////////////////////////////////////////////

SCRIPT dk5indh

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 

			state = SIGASP_APPROACH_3;

		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk6indh

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm_g

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);


// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);




///////////////////////////////////////////////////////////////////////////////

SCRIPT dkhviser

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		wait;
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		Diverte_route_40;
	float		SI_ahead;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);
	Diverte_route_40 = sig_feature (SIGFEAT_USER4);
	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);

	this_state = this_sig_lr(SIGFN_INFO);
	next_state = next_sig_lr(SIGFN_NORMAL);


if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1 )
		{	
			if ( Diverte_route_40 )
			{
				state = SIGASP_APPROACH_1;
			}
			else
			{
				state = SIGASP_APPROACH_2;
			}
		}

	else if (this_state ==# SIGASP_CLEAR_1 || this_state ==# SIGASP_CLEAR_2)
		{
			if (Main_track_40)
			{
				state = SIGASP_APPROACH_1;
			}
			else if (Main_track_60)
			{
				state = SIGASP_APPROACH_2;
			}
			else
			{
				state = SIGASP_CLEAR_1;
				if (SI_ahead &&
 (next_state !=# SIGASP_CLEAR_1 && next_state !=# SIGASP_CLEAR_2 && next_state !=# SIGASP_APPROACH_3))
				{
					state = SIGASP_APPROACH_3;
				}

			}
		}
		else if (this_state ==# SIGASP_APPROACH_3 )
		{	
			if ( Side_track_40 || !route_set() )
			{
				state = SIGASP_APPROACH_1;
			}
			else
			{
				state = SIGASP_APPROACH_2;
			}
		}
		else if (this_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_1;
		}
		else
		{
			state = SIGASP_STOP;
		}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dk3ind_old

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		if (route_set() )
			{
				state = SIGASP_CLEAR_1;
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		else
		{
			state = SIGASP_APPROACH_3;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dk3ind

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;

	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);

// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		if (route_set() )
			{
				state = SIGASP_CLEAR_1;
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		else
		{
			state = SIGASP_APPROACH_3;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dkvisig

// dk platform signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if ( !enabled )
	{
		state = SIGASP_RESTRICTING;
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_APPROACH_1;
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dkvusig

// dk platform signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if ( !enabled )
	{
		state = SIGASP_RESTRICTING;
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	// Block ahead not clear?
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_APPROACH_3;
	}



// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dkpusig

// dk platform signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
if (block_state() ==# BLOCK_JN_OBSTRUCTED )
		{
		state = SIGASP_STOP;
		}
	else if (!enabled || block_state() ==# BLOCK_OCCUPIED ) 		// Block ahead not clear?
									
	{
		state = SIGASP_RESTRICTING;
	}
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP )
		{
			state = SIGASP_RESTRICTING;
		}
		else if (next_state ==# SIGASP_APPROACH_1 || next_state ==# SIGASP_RESTRICTING) 
		{
			state = SIGASP_APPROACH_2;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_2; 
		}
		else if(next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_APPROACH_3;
		}
		else
		{
			state = SIGASP_CLEAR_2;
		}

	}


// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_2udsighkt

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	extern float	route_set ();
	float		next_state;

// If required, show the 'stop' indication.
	 if (!route_set () || !enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED)
 	// Block ahead not clear?
									
	{
		state = SIGASP_STOP;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dkhktblok

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication.
	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( !enabled ) 
	{
		state = SIGASP_RESTRICTING;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_amsighkt

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication.
	if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
	{
		state = SIGASP_STOP;
	}
	else if ( !enabled ) 
	{
		state = SIGASP_RESTRICTING;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dkindhkt

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;
	float		Main_track_70;
	float		Main_track_50;
	float		Side_track_70;
	float		Side_track_50;

	Main_track_70 = sig_feature (SIGFEAT_USER1);
	Main_track_50 = sig_feature (SIGFEAT_USER2);
	Side_track_70 = sig_feature (SIGFEAT_USER3);
	Side_track_50 = sig_feature (SIGFEAT_USER4);

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		state = SIGASP_APPROACH_1;

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if (next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if (next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
	}
	if (route_set() && Main_track_70 && state >=# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	if (route_set() && Main_track_50 && state >=# SIGASP_APPROACH_2 )
	{
		state = SIGASP_APPROACH_2;
	}
	if (!route_set() && Side_track_70 && state >=# SIGASP_APPROACH_3 )
	{
		state = SIGASP_APPROACH_3;
	}
	if (!route_set() && Side_track_50 && state >=# SIGASP_APPROACH_2 )
	{
		state = SIGASP_APPROACH_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkpusighkt

// dk HKT styring

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication.
	 if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED)
 	// Block ahead not clear?
									
	{
		state = SIGASP_STOP;
	}
	else
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_CLEAR_2; 
		}
		else if (next_state ==# SIGASP_APPROACH_3 ) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_1) 
		{
			state = SIGASP_APPROACH_2;
		}
		else 
		{
			state = SIGASP_APPROACH_1;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT dk-dvsighkt

// dk Dvaerg signal head

	extern float	block_state ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	next_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		rangerspor;


	rangerspor = sig_feature (SIGFEAT_USER1);

// If required, show the 'stop' indication.

	if (!enabled ) 
	{
		if ( rangerspor ) 
		{		
			state = SIGASP_STOP_AND_PROCEED;
		}
		else	
		{
			state = SIGASP_STOP;
		}
	}
	else if ( block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED ) 
	// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else 
	{
	
		next_state = next_sig_lr (SIGFN_NORMAL);
		state = SIGASP_RESTRICTING;

		if ( next_state ==# SIGASP_RESTRICTING ) 
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1  ) 
		{
			state = SIGASP_APPROACH_2;
		}
		else if(next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_APPROACH_3; 
		}
		else if(next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_CLEAR_1;
		}
		else if(next_state ==# SIGASP_CLEAR_1 || next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}
//Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_bogvis_A
// dk bogstavsviser A

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show A
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_B
// dk bogstavsviser B

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show B
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_C
// dk bogstavsviser C

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show C
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_D
// dk bogstavsviser D

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show D
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_E
// dk bogstavsviser E

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show E
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_F
// dk bogstavsviser F

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show F
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);
//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_G
// dk bogstavsviser G

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show G
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////

SCRIPT dk_bogvis_H
// dk bogstavsviser H

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show H
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_K
// dk bogstavsviser K

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show K
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_L
// dk bogstavsviser L

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show L
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_M
// dk bogstavsviser M

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show M
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_N
// dk bogstavsviser N

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show N
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_O
// dk bogstavsviser O

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show O
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_P
// dk bogstavsviser P

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show P
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_R
// dk bogstavsviser R

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show R
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_S
// dk bogstavsviser S

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show S
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_T
// dk bogstavsviser T

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal = sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show G
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_U
// dk bogstavsviser U

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal = sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show U
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_V
// dk bogstavsviser V

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float			is_HKT_signal;


	is_HKT_signal = sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 || (this_state !=# SIGASP_STOP && is_HKT_signal) )
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show V
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_bogvis_OE
// dk bogstavsviser OE

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	sig_feature ();
	float		this_state;
	float		is_HKT_signal;


	is_HKT_signal	= sig_feature (SIGFEAT_GRADIENT_PLATE);
	this_state = this_sig_lr (SIGFN_NORMAL);

	state = SIGASP_STOP;

	if (this_state ==# SIGASP_APPROACH_3 || this_state ==# SIGASP_CLEAR_1 ||
			this_state ==# SIGASP_CLEAR_2 ||(this_state !=# SIGASP_STOP && is_HKT_signal))
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show OE
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);

//////////////////////////////////////////////////////////////////////////

SCRIPT dk_retviser_L
// dk Retningsviser Left

	extern float	route_set ();
	extern float	this_sig_mr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state = this_sig_mr (SIGFN_NORMAL);
	state = SIGASP_STOP;

	if (this_state !=# SIGASP_STOP)
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show Left
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);
	

//////////////////////////////////////////////////////////////////////////
SCRIPT dk_retviser_R
// dk Retningsviser Right

	extern float	route_set ();
	extern float	this_sig_mr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	float		this_state;

	this_state = this_sig_mr (SIGFN_NORMAL);
	state = SIGASP_STOP;

	if (this_state !=# SIGASP_STOP)
	{
		if ( route_set() )	// Switch  set as per link?
		{
// Show Right
			state = SIGASP_CLEAR_1;
		}
	}

//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver7sig
// dk Aktiver 7 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver9sig
// dk Aktiver 9 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver11sig
// dk Aktiver 11 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver13sig
// dk Aktiver 13 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver15sig
// dk Aktiver 15 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver17sig
// dk Aktiver 17 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);


SCRIPT aktiver19sig
// dk Aktiver 19 signaler

	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( !enabled )	
							 
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}
//Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT KBsig_Point

// Sporskiftesignal

	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;

	if ( route_set() )		// Switch set as per link (straight branch)?
	{
		state = SIGASP_CLEAR_2;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed30

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	this_sig_mr ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		wait;
	float		next_state;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);
	next_state = next_sig_lr(SIGFN_NORMAL);


if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}




// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed40

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed50

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed60

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed80

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_2;	
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed100

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_2;	
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed120

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_2;	
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed130

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_2;	
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk_speed140

// dk speedindicator

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		wait;
	float		this_state;

	this_state = this_sig_lr(SIGFN_INFO);



if (block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else if (this_state ==# SIGASP_APPROACH_1)
	{
		state = SIGASP_APPROACH_2;	
	}
	else
	{	
		state = this_state;
	}



// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4indv_old

// dkind signal head 4 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
//		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			SI_state = next_sig_lr (SIGFN_INFO);
			state = SIGASP_CLEAR_1;
			if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
			{
				state = SIGASP_CLEAR_2;
			} 
			else
			{
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT dk5indv_old

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT left_arm_old

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 
			state = SIGASP_APPROACH_3;
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT dk6indv_old

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Left_arm_g_old

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);



// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dk4indh_old

// dkind signal head 4 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
//		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
		
			SI_state = next_sig_lr (SIGFN_INFO);
			state = SIGASP_CLEAR_1;
			if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
			{
				state = SIGASP_CLEAR_2;
			} 
			else
			{
				if (Main_track_60) 
				{
					state = SIGASP_APPROACH_3;
				}
				if (Main_track_40) 
				{
					state = SIGASP_APPROACH_2;
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);



///////////////////////////////////////////////////////////////////////////////

SCRIPT dk5indh_old

// dkind signal head 5 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
				{
					state = SIGASP_CLEAR_2;
				} 
				else
				{
					if (Main_track_60) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm_old

// dkind signal head 5 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		Restricting_40;


// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		if (route_set())
// The divert route is set 
		{	
			state = SIGASP_RESTRICTING;
		}
		else
		{
			state = SIGASP_STOP;
		}
	}
	else if (route_set())
		{				// Switch set as per link?
// The divert route is set 

			state = SIGASP_APPROACH_3;

		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////

SCRIPT dk6indh_old

// dkind signal head 6 lights

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		this_state;
	float		Main_track_60;
	float		Main_track_40;
	float		Side_track_40;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_NUMBER_PLATE);
	Main_track_60 = sig_feature (SIGFEAT_USER1);
	Main_track_40 = sig_feature (SIGFEAT_USER2);
	Side_track_40 = sig_feature (SIGFEAT_USER3);



// If required, show the 'stop' indication.
	if (!enabled ||block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		next_state = next_sig_lr (SIGFN_NORMAL);
		this_state = this_sig_lr (SIGFN_REPEATER);
		if (this_state !=# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_1;	
		}
		else if (route_set())
		{				// Switch set as per link?
			if ( next_state ==# SIGASP_CLEAR_2 )
			{
				state = SIGASP_CLEAR_2;
			}
			else
			{
				SI_state = next_sig_lr (SIGFN_INFO);
				state = SIGASP_CLEAR_1;

				if (SI_ahead && SI_state ==# SIGASP_CLEAR_2) 
					{
						state = SIGASP_CLEAR_2;
					} 
				else
				{
					state = SIGASP_CLEAR_1;
					if ( Main_track_60 ) 
					{
						state = SIGASP_APPROACH_3;
					}
					if (Main_track_40 ) 
					{
						state = SIGASP_APPROACH_2;
					}
				}
			}
		}
		else
		{

			state = SIGASP_APPROACH_3;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);
///////////////////////////////////////////////////////////////////////////////


SCRIPT Right_arm_g_old

// dkind signal head 6 lights arm 

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	extern float	sig_feature ();
	float		next_state;
	float		SI_ahead;
	float		SI_state;

	SI_ahead = sig_feature (SIGFEAT_GRADIENT_PLATE);


// If required, show the 'stop' indication.
	if (!enabled )
	{
		state = SIGASP_STOP;
	}
	else
	{
		if ( block_state() !=# BLOCK_CLEAR )
// Block ahead not clear?
		{
			if (route_set())
// The divert route is set 
			{	
				state = SIGASP_RESTRICTING;
			}
			else
			{
				state = SIGASP_STOP;
			}
		}
		else if (route_set())
		{
// Switch set as per link?
// The divert route is set 
			next_state = next_sig_lr (SIGFN_NORMAL);
			SI_state = next_sig_lr (SIGFN_INFO);
			if ( next_state ==# SIGASP_CLEAR_2 || (SI_ahead && SI_state ==# SIGASP_CLEAR_2))
			{
				state = SIGASP_CLEAR_1;
			}
			else
			{
				state = SIGASP_APPROACH_3;
			}
		}
		else
		{

			state = SIGASP_APPROACH_1;
		}
	}
//
//
// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT dktusig_bag
// dk TU signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

	state = this_sig_lr (SIGFN_NORMAL);

//	if (!enabled || block_state() ==# BLOCK_JN_OBSTRUCTED )
//	
//	{
//		state = SIGASP_STOP;
//	}
//	else if ( next_state ==# SIGASP_CLEAR_1 || next_state==# SIGASP_CLEAR_2 )							 
//	{
//		state = SIGASP_CLEAR_2;
//	}
//	else if (next_state ==# SIGASP_APPROACH_3 )
//	{
//		state = SIGASP_APPROACH_3;
//	}
//	else 
//	{
//		state = SIGASP_STOP;
//	}	

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivind

// dkind signal head 3 lamps

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// If required, show the 'stop' indication.
	if (!enabled || block_state() ==# BLOCK_OCCUPIED || block_state() ==# BLOCK_JN_OBSTRUCTED  )
		// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else 
	{
		if ( route_set() )
			{
				state = SIGASP_CLEAR_1;
			}
		else
		{
			state = SIGASP_APPROACH_3;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////


SCRIPT dkprivud
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// If required, show the 'stop' indication.
	if ( route_set () && enabled && block_state() ==# BLOCK_CLEAR )	// Block ahead not clear?
							 
	{
		state = SIGASP_CLEAR_2;
	}
	else
	{
		state = SIGASP_STOP;	
	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivud2
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	opp_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;

// If required, show the 'stop' indication

		state = next_sig_lr ( SIGFN_INFO );


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivper
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float		next_state;
	float		sidespor;


	sidespor = sig_feature ( SIGFEAT_USER1 );

	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( route_set () && enabled && block_state() !=# BLOCK_JN_OBSTRUCTED && next_state ==# SIGASP_CLEAR_2 )
	// Block ahead not clear?
	{
		if ( sidespor )
			{
				state = SIGASP_APPROACH_3;
			}
		else
			{
				state = SIGASP_CLEAR_2;
			}
	}
	else
	{
			state = SIGASP_STOP;
	}


// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT dkprivper2
// dkud signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	sig_feature ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	float		sidespor;

	sidespor = sig_feature ( SIGFEAT_USER1 );

// If required, show the 'stop' indication.
	if ( sidespor )	// Block ahead not clear?
							 
	{
		state = SIGASP_APPROACH_3;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}


// Get draw state
	draw_state = def_draw_state (state);
